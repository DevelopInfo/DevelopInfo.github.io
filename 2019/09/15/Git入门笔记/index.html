<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Git 入门笔记 | DevelopInfo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Git 入门笔记[TOC] 本文主要参考Git官方教程及git易百教程，整理介绍Git版本管理工具的一些基本概念以及基本操作。 1. Git是什么？Git是一种版本控制工具，版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。版本控制系统具有三种类型，分别是：本地版本控制系统、集中化的版本控制系统和分布式版本控制系统。三种类型系统的形态如下图所示:   本地版本控制系统">
<meta property="og:type" content="article">
<meta property="og:title" content="Git 入门笔记">
<meta property="og:url" content="http://yoursite.com/2019/09/15/Git入门笔记/index.html">
<meta property="og:site_name" content="DevelopInfo">
<meta property="og:description" content="Git 入门笔记[TOC] 本文主要参考Git官方教程及git易百教程，整理介绍Git版本管理工具的一些基本概念以及基本操作。 1. Git是什么？Git是一种版本控制工具，版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。版本控制系统具有三种类型，分别是：本地版本控制系统、集中化的版本控制系统和分布式版本控制系统。三种类型系统的形态如下图所示:   本地版本控制系统">
<meta property="og:locale" content="zh">
<meta property="og:image" content="http://zhoujianbo.gitee.io/notes/pics/Git/vcs1.png">
<meta property="og:image" content="http://zhoujianbo.gitee.io/notes/pics/Git/vcs2.png">
<meta property="og:image" content="http://zhoujianbo.gitee.io/notes/pics/Git/vcs3.png">
<meta property="og:image" content="http://zhoujianbo.gitee.io/notes/pics/Git/deltas.png">
<meta property="og:image" content="http://zhoujianbo.gitee.io/notes/pics/Git/snapshots.png">
<meta property="og:image" content="http://zhoujianbo.gitee.io/notes/pics/Git/workAreas.png">
<meta property="og:image" content="http://zhoujianbo.gitee.io/notes/pics/Git/lifecycle.png">
<meta property="og:image" content="http://zhoujianbo.gitee.io/notes/pics/Git/commit-and-tree.png">
<meta property="og:image" content="http://zhoujianbo.gitee.io/notes/pics/Git/commits-and-parents.png">
<meta property="og:image" content="http://zhoujianbo.gitee.io/notes/pics/Git/two-branches.png">
<meta property="og:image" content="http://zhoujianbo.gitee.io/notes/pics/Git/head-to-master.png">
<meta property="og:image" content="http://zhoujianbo.gitee.io/notes/pics/Git/head-to-testing.png">
<meta property="og:image" content="http://zhoujianbo.gitee.io/notes/pics/Git/advance-testing.png">
<meta property="og:image" content="http://zhoujianbo.gitee.io/notes/pics/Git/checkout-master.png">
<meta property="og:image" content="http://zhoujianbo.gitee.io/notes/pics/Git/advance-master.png">
<meta property="og:image" content="http://zhoujianbo.gitee.io/notes/pics/Git/basic-branching-5.png">
<meta property="og:image" content="http://zhoujianbo.gitee.io/notes/pics/Git/basic-merging-1.png">
<meta property="og:image" content="http://zhoujianbo.gitee.io/notes/pics/Git/basic-merging-2.png">
<meta property="og:updated_time" content="2019-09-15T12:48:28.211Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Git 入门笔记">
<meta name="twitter:description" content="Git 入门笔记[TOC] 本文主要参考Git官方教程及git易百教程，整理介绍Git版本管理工具的一些基本概念以及基本操作。 1. Git是什么？Git是一种版本控制工具，版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。版本控制系统具有三种类型，分别是：本地版本控制系统、集中化的版本控制系统和分布式版本控制系统。三种类型系统的形态如下图所示:   本地版本控制系统">
<meta name="twitter:image" content="http://zhoujianbo.gitee.io/notes/pics/Git/vcs1.png">
  
    <link rel="alternate" href="/atom.xml" title="DevelopInfo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">DevelopInfo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Git入门笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/15/Git入门笔记/" class="article-date">
  <time datetime="2019-09-15T12:43:26.880Z" itemprop="datePublished">2019-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Git 入门笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Git-入门笔记"><a href="#Git-入门笔记" class="headerlink" title="Git 入门笔记"></a>Git 入门笔记</h1><p>[TOC]</p>
<p>本文主要参考<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Git官方教程</a>及<a href="https://www.yiibai.com/git/" target="_blank" rel="noopener">git易百教程</a>，整理介绍Git版本管理工具的一些基本概念以及基本操作。</p>
<h2 id="1-Git是什么？"><a href="#1-Git是什么？" class="headerlink" title="1. Git是什么？"></a>1. Git是什么？</h2><p>Git是一种<strong>版本控制工具</strong>，版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。版本控制系统具有三种类型，分别是：本地版本控制系统、集中化的版本控制系统和分布式版本控制系统。三种类型系统的形态如下图所示:</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/vcs1.png" width="50%"></center>

<center>本地版本控制系统</center>

<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/vcs2.png" width="50%"></center>

<center>集中式版本控制系统</center>

<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/vcs3.png" width="50%"></center>

<center>分布式版本控制系统</center>

<p>其中，Git就是分布式版本控制系统，对于这三种系统的优缺点这里不做介绍。</p>
<p>个人理解，Git的入门可以划分为三个层次：第一是单分支操作，第二是多分支操作，第三是加入远程分支之后的操作。下文将分别介绍这三种情况下的一些基本概念与操作。</p>
<h2 id="2-Git单分支操作"><a href="#2-Git单分支操作" class="headerlink" title="2. Git单分支操作"></a>2. Git单分支操作</h2><p>在开始使用Git工具时，我们可能并未考虑到分支操作，以及远程仓库的使用。本节将主要介绍Git工具的基本概念以及单分支本地操作，包括Git如何保存数据，Git项目管理的三个工作区域，如何获取Git仓库，如何跟新每次提交到仓库，如何查看提交历史，如何撤销Git操作。</p>
<h3 id="2-1-直接记录快照，而非差异比较"><a href="#2-1-直接记录快照，而非差异比较" class="headerlink" title="2.1 直接记录快照，而非差异比较"></a>2.1 直接记录快照，而非差异比较</h3><p>首先，Git在记录每个版本时，它记录的是什么？有些版本控制系统记录的是基本文件和每个文件随时间逐步积累的差异。如下图所示:</p>
<p>首先，Git在记录每个版本时，他记录的是什么？有些版本控制系统记录的是基本文件和每个文件随时间逐步积累的差异，如下图所示。</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/deltas.png" width="80%"></center>

<center>存储每个文件与初始版本的差异</center>

<p>而Git和其他版本控制系统存在一些区别，它主要记录的是文件<strong>快照</strong>。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong>。存储项目随时间改变的快照如下图所示:</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/snapshots.png" width="80%"></center>

<center>存储项目随时间改变的快照</center>

<p>那么，文件快照是什么？下文会做介绍。</p>
<h3 id="2-2-三个区域"><a href="#2-2-三个区域" class="headerlink" title="2.2 三个区域"></a>2.2 三个区域</h3><p>为之后更好理解Git，这里介绍Git项目的三个工作区域：Git仓库、暂存区域以及工作目录。三个工作区域的关系如下图所示:</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/workAreas.png" width="80%"></center>

<center>工作目录、暂存区域以及 Git 仓库</center>

<p>工作目录工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p>
<p>暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。</p>
<p>Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</p>
<h3 id="2-3-获取Git仓库"><a href="#2-3-获取Git仓库" class="headerlink" title="2.3 获取Git仓库"></a>2.3 获取Git仓库</h3><p>在本地创建一个Git管理的项目，首先需要获取Git仓库，有两种取得 Git 项目仓库的方法： 第一种是在现有项目或目录下导入所有文件到 Git 中； 第二种是从一个服务器克隆一个现有的 Git 仓库。</p>
<p><strong>第一种方式</strong>，你只需要进入项目目录并输入：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>该命令将创建一个名为 <code>.git</code> 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。</p>
<p><strong>第二种方式</strong>，你将获得一份已经存在了的 Git 仓库的拷贝。克隆仓库的命令格式是 <code>git clone [url]</code> 。 比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/libgit2/libgit2</span><br></pre></td></tr></table></figure>

<p>这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹，从远程仓库拉取下所有数据放入 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝。</p>
<p> 如果你进入到这个新建的 <code>libgit2</code> 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。 如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/libgit2/libgit2 mylibgit</span><br></pre></td></tr></table></figure>

<p>这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为 <code>mylibgit</code>。</p>
<h3 id="2-4-记录每次更新到仓库"><a href="#2-4-记录每次更新到仓库" class="headerlink" title="2.4 记录每次更新到仓库"></a>2.4 记录每次更新到仓库</h3><p>现在我们手上有了一个真实项目的 Git 仓库，接下来，对项目文件做些修改，在完成了一个阶段的目标之后，提交本次更新到仓库。本节将介绍在此过程中文件状态的转换和需要的操作。</p>
<p><strong>文件状态</strong></p>
<p>文件状态都不外乎两种状态：<strong>已追踪</strong>和<strong>未追踪</strong>。<strong>已跟踪的文件</strong>是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。工作目录中除已跟踪文件以外的所有其它文件都属于<strong>未跟踪文件</strong>，它们既不存在于上次快照的记录中，也没有放入暂存区。同时，已追踪状态又可分为：<strong>未修改(Unmodified)/已提交(Committed)、已修改(Modified)和已暂存(Staged)</strong>。</p>
<p>当我们在项目中新建一个文件时，该文件处于未追踪(Untracked)状态；我们输入添加命令，文件进入暂存状态；我们输入提交命令后，文件进入已提交状态或者叫未修改状态；自上次提交后我们对文件做了修改，文件进入已修改状态；我们在此输入添加命令，文件再次进入已暂存状态。如此反复，Git项目下的文件生命周期如下图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/lifecycle.png" width="80%"></center>

<center>文件的状态变化周期</center>

<p><strong>查看当前文件状态</strong></p>
<p>我们要<strong>查看哪些文件处于什么状态</strong>，可以用 <code>git status</code> 命令。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>

<p><strong>追踪新文件</strong></p>
<p>我们要<strong>追踪一个文件</strong>，可以使用命令 <code>git add [file]</code> 。 例如，我们要跟踪 README 文件，可以运行<code>git add README</code>命令。</p>
<p><strong>暂存已修改文件</strong></p>
<p>当我们修改了一个已被跟踪并处于暂存状态的文件，则该文件将变为已修改状态，我们需要重新运行命令 <code>git add [file]</code> 使其进入暂存状态。例如，如果我们修改了一个名为 <code>CONTRIBUTING.md</code> 的已被跟踪的文件，我们可以运行 <code>git add CONTRIBUTING.md</code> 将”CONTRIBUTING.md”重新放到暂存区。</p>
<p><strong>提交更新到仓库</strong></p>
<p>我们要<strong>提交更新到仓库</strong>，可以使用命令<code>git commit</code>。<strong>Git只会提交处于暂存状态的文件给仓库</strong>。因此，在此之前，请一定要确认还有什么修改过的或新建的文件还没有 <code>git add</code> 过，否则提交的时候不会记录这些还没暂存起来的变化。 这些修改过的文件只保留在本地磁盘。 所以，每次准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>。</p>
<p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个<strong>跳过使用暂存区域</strong>的方式， 只要在提交的时候，给 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤。</p>
<p><strong>忽略文件</strong></p>
<p>有时我们需要<strong>忽略一些文件</strong>，这些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件模式。文件 <code>.gitignore</code> 的格式规范如下：</p>
<ul>
<li>所有空行或者以 <code>＃</code> 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配。</li>
<li>匹配模式可以以（<code>/</code>）开头防止递归。</li>
<li>匹配模式可以以（<code>/</code>）结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反。</li>
</ul>
<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code>匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。 使用两个星号（<code>*</code>) 表示匹配任意中间目录，比如 <code>a/**/z</code> 可以匹配 <code>a/z</code> , <code>a/b/z</code> 或 <code>a/b/c/z</code> 等。我们看一个 <code>.gitignore</code> 文件的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># no .a files</span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"># but do track lib.a, even though you&apos;re ignoring .a files above</span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"># only ignore the TODO file in the current directory, not subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"># ignore all files in the build/ directory</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"># ignore doc/notes.txt, but not doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"># ignore all .pdf files in the doc/ directory</span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure>

<p><strong>查看已暂存和未暂存的修改</strong></p>
<p>有时，我们需要查看尚未暂存的文件更新了哪些部分，可以不加参数直接输入 <code>git diff</code>。此命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。</p>
<p>若要查看已暂存的将要添加到下次提交里的内容，可以用 <code>git diff --cached</code> 命令。（Git 1.6.1 及更高版本还允许使用 <code>git diff --staged</code>，效果是相同的，但更好记些。）</p>
<p><strong>移除文件</strong></p>
<p>有时，我们需要从 Git 中移除已被追踪某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 <code>git rm [file]</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p>
<p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <code>-f</code>（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。</p>
<p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。比如，当你忘记添加 <code>.gitignore</code> 文件，不小心把一个很大的日志文件或一堆 <code>.a</code> 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 <code>--cached</code> 选项。例如，我们向让已被暂存的README文件从Git控制中删除，但需要其保留在磁盘中，我们可以输入命令<code>git rm --cached README</code>完成操作。</p>
<p>另外，<code>git rm</code> 命令后面可以列出文件或者目录的名字，也可以使用 <code>glob</code> 模式。例如：<code>git rm log/\*.log</code>，注意到星号 <code>*</code> 之前的反斜杠 <code>\</code>， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。 此命令删除 <code>log/</code> 目录下扩展名为 <code>.log</code> 的所有文件。</p>
<p><strong>移动文件</strong></p>
<p>有时，我们会移动或重命名文件，可以运行<code>git mv &lt;options&gt; ... &lt;args&gt; ...</code>完成操作。该命令存在两种形式的调用，第一种形式是重命名操作，调用方式为<code>git mv &lt;source&gt; &lt;destination&gt;</code>；第二种方式是移动文件操作，盗用方式为<code>git mv &lt;source&gt; ... &lt;destination directory&gt;</code>。</p>
<p>例如，把 文件<em>text.txt</em> 移动到 <em>mydir</em>目录下，可以执行以下操作 - </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mv text.txt mydir</span><br></pre></td></tr></table></figure>

<p>运行上面的 <code>git mv</code> 其实就相当于运行了<code>3</code>条命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv test.txt mydir/</span><br><span class="line">$ git rm test.txt</span><br><span class="line">$ git add mydr</span><br></pre></td></tr></table></figure>

<h3 id="2-5-查看提交历史"><a href="#2-5-查看提交历史" class="headerlink" title="2.5 查看提交历史"></a>2.5 查看提交历史</h3><p>有时，我们需要查看一下Git项目中文件的提交历史情况，本节将介绍命令<code>git log</code>，并列举一些该命令的常用选项。</p>
<p><strong>查看提交的基本历史信息</strong></p>
<p>运行 git log，应该会看到下面的输出：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure>

<p>默认不用任何参数的话，<code>git log</code> 会按提交时间列出所有的更新，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p>
<p><strong>查看每次提交的内容差异</strong></p>
<p>如果，我们想查看每次提交的内容差异，可以利用选项<code>-p</code>，并加上 <code>-2</code> 来仅显示最近两次提交：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p -2</span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br><span class="line"></span><br><span class="line">diff --git a/Rakefile b/Rakefile</span><br><span class="line">index a874b73..8f94139 100644</span><br><span class="line">--- a/Rakefile</span><br><span class="line">+++ b/Rakefile</span><br><span class="line">@@ -5,7 +5,7 @@ require 'rake/gempackagetask'</span><br><span class="line"> spec = Gem::Specification.new do |s|</span><br><span class="line">     s.platform  =   Gem::Platform::RUBY</span><br><span class="line">     s.name      =   "simplegit"</span><br><span class="line">-    s.version   =   "0.1.0"</span><br><span class="line">+    s.version   =   "0.1.1"</span><br><span class="line">     s.author    =   "Scott Chacon"</span><br><span class="line">     s.email     =   "schacon@gee-mail.com"</span><br><span class="line">     s.summary   =   "A simple gem for using Git in Ruby code."</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test</span><br><span class="line"></span><br><span class="line">diff --git a/lib/simplegit.rb b/lib/simplegit.rb</span><br><span class="line">index a0a60ae..47c6340 100644</span><br><span class="line">--- a/lib/simplegit.rb</span><br><span class="line">+++ b/lib/simplegit.rb</span><br><span class="line">@@ -18,8 +18,3 @@ class SimpleGit</span><br><span class="line">     end</span><br><span class="line"></span><br><span class="line"> end</span><br><span class="line">-</span><br><span class="line">-if $0 == __FILE__</span><br><span class="line">-  git = SimpleGit.new</span><br><span class="line">-  puts git.show</span><br><span class="line">-end</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure>

<p>该选项除了显示基本信息之外，还附带了每次 commit 的变化。 当进行代码审查，或者快速浏览某个搭档提交的 commit 所带来的变化的时候，这个参数就非常有用了。 </p>
<p><strong>查看格式化的提交历史</strong></p>
<p>另外一个常用的选项是 <code>--pretty</code>。 这个选项可以指定使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如用 <code>oneline</code> 将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有 <code>short</code>，<code>full</code> 和 <code>fuller</code> 可以用，展示的信息或多或少有些不同，请自己动手实践一下看看效果如何。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">ca82a6dff817ec66f44342007202690a93763949 changed the version number</span><br><span class="line">085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test</span><br><span class="line">a11bef06a3f659402fe7563abf99ad00de2209e6 first commit</span><br></pre></td></tr></table></figure>

<p>但最有意思的是 format，可以定制要显示的记录格式。 这样的输出对后期提取分析格外有用 — 因为你知道输出的格式不会随着 Git 的更新而发生改变：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=format:<span class="string">"%h - %an, %ar : %s"</span></span></span><br><span class="line">ca82a6d - Scott Chacon, 6 years ago : changed the version number</span><br><span class="line">085bb3b - Scott Chacon, 6 years ago : removed unnecessary test</span><br><span class="line">a11bef0 - Scott Chacon, 6 years ago : first commit</span><br></pre></td></tr></table></figure>

<p><a href="https://git-scm.com/book/zh/v2/ch00/rpretty_format" target="_blank" rel="noopener"><code>git log --pretty=format</code> 常用的选项</a> 列出了常用的格式占位符写法及其代表的意义。</p>
<p>当 oneline 或 format 与另一个 <code>log</code> 选项 <code>--graph</code> 结合使用时尤其有用。 这个选项添加了一些ASCII字符串来形象地展示你的分支、合并历史：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=format:<span class="string">"%h %s"</span> --graph</span></span><br><span class="line">* 2d3acf9 ignore errors from SIGCHLD on trap</span><br><span class="line">*  5e3ee11 Merge branch 'master' of git://github.com/dustin/grit</span><br><span class="line">|\</span><br><span class="line">| * 420eac9 Added a method for getting the current branch.</span><br><span class="line">* | 30e367c timeout code and tests</span><br><span class="line">* | 5a09431 add timeout protection to grit</span><br><span class="line">* | e1193f8 support for heads with slashes in them</span><br><span class="line">|/</span><br><span class="line">* d6016bc require time for xmlschema</span><br><span class="line">*  11d191e Merge branch 'defunkt' into local</span><br></pre></td></tr></table></figure>

<p>这种输出类型会在学完分支与合并以后变得更加有趣。</p>
<h3 id="2-6-撤销操作"><a href="#2-6-撤销操作" class="headerlink" title="2.6 撤销操作"></a>2.6 撤销操作</h3><p>有时，我们存在操作错误，需要撤销操作，本节将简单介绍如何取消提交操作，如何取消暂存文件，如何撤销已修改的文件，以及如何取消远程仓库的push，</p>
<p><strong>提交（commit）操作的撤销</strong></p>
<p>有时，我们commit之后，想撤销commit操作，分为以下几种情况：提交后发现注释写错了或有几个文件没有提交，提交后发现许多文件不应该提交。</p>
<p>第一种情况，我们可以先运行<code>git add [file-name]</code>将文件加入暂存区域，利用<code>git commit -amend</code>，进入注释编辑界面，输入注释，完成提交，这样的操作会覆盖之前最后一次提交操作。</p>
<p>第二种情况，我们可以运行<code>git reset --soft HEAD~1</code>撤销最后一次提交操作，但不撤销<code>git add</code>操作；也可以运行<code>git reset --mixed HEAD~1</code>撤销最后一次提交操作，并且撤销<code>git add</code>操作；注意命令<code>git reset --hard HEAD~1</code>完成这个操作后，就恢复到了上一次的commit状态。</p>
<p><strong>取消暂存</strong></p>
<p>有时，你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 <code>git add *</code> 暂存了它们两个。 如何只取消暂存两个中的一个呢？比如我么需要取消暂存 <code>CONTRIBUTING.md</code> 文件，我们可以运行以下命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset HEAD CONTRIBUTING.md</span></span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M	CONTRIBUTING.md</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use "git reset HEAD &lt;file&gt;..." to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add &lt;file&gt;..." to update what will be committed)</span><br><span class="line">  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>

<p>这样 <code>CONTRIBUTING.md</code> 文件已经是修改未暂存的状态了。</p>
<p><strong>撤销已修改的文件</strong></p>
<p>如果你并不想保留对 <code>CONTRIBUTING.md</code> 文件的修改怎么办？ 你该如何方便地撤消修改 ？我们可以执行：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add &lt;file&gt;..." to update what will be committed)</span><br><span class="line">  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- CONTRIBUTING.md</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use "git reset HEAD &lt;file&gt;..." to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br></pre></td></tr></table></figure>

<p>可以看到那些修改已经被撤消了。</p>
<p><strong>取消远程仓库的push</strong></p>
<p>有时，我们把错误的本地提交推送到了远程仓库中，当我们在本地撤销提交后，如何将落后于远程追踪分支的本地分支推送至远程仓库呢？一种可行的做法是运行命令<code>git push -f [remote-name]</code>，将当前本地分支强制推送到远程分支。</p>
<h2 id="3-Git多分支操作"><a href="#3-Git多分支操作" class="headerlink" title="3. Git多分支操作"></a>3. Git多分支操作</h2><p>上节介绍了Git在单分支场景下文件的状态和操作，本节将介绍Git在多分支场景下的操作，包括：Git是如何保存数据的，如何创建分支，如何切换分支，如何合并与删除分支，以及一些分支信息查看的分支管理命令。</p>
<h3 id="3-1-Git是如何保存数据的？"><a href="#3-1-Git是如何保存数据的？" class="headerlink" title="3.1 Git是如何保存数据的？"></a>3.1 Git是如何保存数据的？</h3><p>为了真正理解 Git 处理分支的方式，我们需要回顾一下 Git 是如何保存数据的。本文开头介绍了Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。那它是如何保存这些数据的呢？</p>
<p>在进行提交操作时，Git 会保存一个<strong>提交对象（commit object）</strong>。该对象包含包含<strong>一个指向暂存内容快照的指针</strong>、<strong>作者的姓名和邮箱</strong>、<strong>提交时输入的信息</strong>以及<strong>指向它的父对象的指针</strong>。其中，首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象。</p>
<p>为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。<strong>暂存操作</strong>会为每一个文件计算校验和（使用 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交。当进行<strong>提交操作</strong>时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git 仓库中这些校验和保存为树对象。 随后，Git 便会创建一个提交对象。这样，Git 仓库中有五个对象：<strong>三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）</strong>。首次提交对象及其树结构如图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/commit-and-tree.png">

<center>首次提交对象及其树结构</center>

<p>做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。如图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/commits-and-parents.png"></center>


<center>提交对象及其父对象</center>

<p>Git 的分支，其实本质上仅仅是<strong>指向提交对象的可变指针</strong>。</p>
<h3 id="3-2-分支创建"><a href="#3-2-分支创建" class="headerlink" title="3.2 分支创建"></a>3.2 分支创建</h3><p>Git 的默认分支名字是 <code>master</code>。 Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 <code>git branch</code> 命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch testing</span></span><br></pre></td></tr></table></figure>

<p>这会在当前所在的提交对象上创建一个指针。</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/two-branches.png" width="80%"></center>

<center>两个指向相同提交历史的分支</center>

<p>那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 <code>HEAD</code> 的特殊指针。在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 <code>HEAD</code> 想象为当前分支的别名）。 在本例中，你仍然在 <code>master</code> 分支上。 因为 <code>git branch</code> 命令仅仅 <em>创建</em> 一个新分支，并不会自动切换到新分支中去。</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/head-to-master.png" width="80%"></center>

<center>HEAD 指向当前所在的分支</center>

<h3 id="3-3-分支切换"><a href="#3-3-分支切换" class="headerlink" title="3.3 分支切换"></a>3.3 分支切换</h3><p><strong>切换分支到testing</strong></p>
<p>有时，我们需要切换到一个已存在的分支，可以使用 <code>git checkout</code> 命令。 我们现在切换到新创建的 <code>testing</code> 分支去：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout testing</span></span><br></pre></td></tr></table></figure>

<p>这样 <code>HEAD</code> 就指向 <code>testing</code> 分支了，如图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/head-to-testing.png" width="80%"></center>

<center>HEAD 指向当前所在的分支</center>

<p><strong>再次提交testing分支</strong></p>
<p>那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim test.rb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m <span class="string">'made a change'</span></span></span><br></pre></td></tr></table></figure>

<p>如图所示，<code>testing</code> 分支向前移动了，但是 <code>master</code> 分支却没有，它仍然指向运行 <code>git checkout</code> 时所指的对象。</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/advance-testing.png" width="80%"></center>

<center>HEAD 分支随着提交操作自动向前移动</center>

<p><strong>切换回master分支</strong></p>
<p>现在我们切换回 <code>master</code> 分支看看：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br></pre></td></tr></table></figure>

<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/checkout-master.png" width="80%"></center>

<center>检出时 HEAD 随之移动</center>

<p>这条命令做了两件事。 一是使 HEAD 指回 <code>master</code> 分支，二是将工作目录恢复成 <code>master</code> 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 <code>testing</code>分支所做的修改，以便于向另一个方向进行开发。</p>
<p><strong>master分支修改后再次提交</strong></p>
<p>我们不妨再稍微做些修改并提交：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim test.rb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m <span class="string">'made other changes'</span></span></span><br></pre></td></tr></table></figure>

<p>现在，这个项目的提交历史已经产生了分叉（参见 <a href="https://git-scm.com/book/zh/v2/ch00/rdivergent_history" target="_blank" rel="noopener">项目分叉历史</a>）。</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/advance-master.png" width="80%"></center>

<center>项目分叉历史</center>

<p>因为刚才我们创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 <code>branch</code>、<code>checkout</code> 和 <code>commit</code>。</p>
<p>由于 Git 的分支实质上仅是<strong>包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件</strong>，创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），所以它的创建和销毁都异常高效。</p>
<h3 id="3-4-分支合并删除"><a href="#3-4-分支合并删除" class="headerlink" title="3.4 分支合并删除"></a>3.4 分支合并删除</h3><p>本节将一个例子讲解分支的合并。</p>
<p><strong>新建iss53分支，并进行一次提交</strong></p>
<p>现在，假如你需要要解决项目中的 #53 问题。 你可以在<code>master</code>分支的基础上新建一个<code>iss53</code>分支并同时切换到这个分支上，运行一个带有 <code>-b</code> 参数的 <code>git checkout</code> 命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b iss53</span></span><br><span class="line">Switched to a new branch "iss53"</span><br></pre></td></tr></table></figure>

<p>它是下面两条命令的简写：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch iss53</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout iss53</span></span><br></pre></td></tr></table></figure>

<p>你继续在 #53 问题上工作，并且做了一些提交。 在此过程中，<code>iss53</code> 分支在不断的向前推进，因为你已经检出到该分支（也就是说，你的 <code>HEAD</code> 指针指向了 <code>iss53</code> 分支）</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim index.html</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m <span class="string">'added a new footer [issue 53]'</span></span></span><br></pre></td></tr></table></figure>

<p><strong>新建hotfix分支，并进行一次提交</strong></p>
<p>现在你接到那个电话，有个紧急问题等待你来解决。你可以在<code>master</code>分支的基础上新建一个<code>hotfix</code>分支并同时切换到这个分支上，在该分支上工作直到问题解决：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b hotfix</span></span><br><span class="line">Switched to a new branch 'hotfix'</span><br><span class="line"><span class="meta">$</span><span class="bash"> vim index.html</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m <span class="string">'fixed the broken email address'</span></span></span><br><span class="line">[hotfix 1fb7853] fixed the broken email address</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure>

<p><strong>master分支与hotfix分支合并（快进合并）</strong></p>
<p>当紧急问题解决后，你需要合并回 <code>master</code> 分支。 你可以使用 <code>git merge</code> 命令来达到上述目的：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge hotfix</span></span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast-forward</span><br><span class="line"> index.html | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure>

<p>在合并的时候，你应该注意到了”快进（fast-forward）”这个词。 由于当前 <code>master</code> 分支所指向的提交是你当前提交（有关 hotfix 的提交）的直接上游，所以 Git 只是简单的将指针向前移动。</p>
<p>现在，最新的修改已经在 <code>master</code> 分支所指向的提交快照中，你可以着手发布该修复了。如图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/basic-branching-5.png" width="80%"></center>

<center> `master` 被快进到 `hotfix` </center>

<p><strong><code>hotfix</code>分支删除</strong></p>
<p>关于这个紧急问题的解决方案发布之后，你应该先删除 <code>hotfix</code>分支，因为你已经不再需要它了 —— <code>master</code> 分支已经指向了同一个位置。 你可以使用带 <code>-d</code> 选项的 <code>git branch</code> 命令来删除分支：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d hotfix</span></span><br><span class="line">Deleted branch hotfix (3a0874c)</span><br></pre></td></tr></table></figure>

<p><strong><code>iss53</code>分支完成后，合并到<code>master</code>分支中（无冲突合并）</strong></p>
<p>现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53 问题的那个分支（iss53 分支）。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout iss53</span></span><br><span class="line">Switched to branch "iss53"</span><br><span class="line"><span class="meta">$</span><span class="bash"> vim index.html</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m <span class="string">'finished the new footer [issue 53]'</span></span></span><br><span class="line">[iss53 ad82d7a] finished the new footer [issue 53]</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>假设你已经修正了 #53 问题，并且打算将你的工作合并入 <code>master</code> 分支。 为此，你需要合并 <code>iss53</code> 分支到 <code>master</code> 分支，这和之前你合并 <code>hotfix</code> 分支所做的工作差不多。 你只需要检出到你想合并入的分支，然后运行 <code>git merge</code> 命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line">Switched to branch 'master'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge iss53</span></span><br><span class="line">Merge made by the 'recursive' strategy.</span><br><span class="line">index.html |    1 +</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>这和之前合并 <code>hotfix</code> 分支的时候看起来有一点不一样。 在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，<code>master</code> 分支所在提交并不是 <code>iss53</code> 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（<code>C4</code> 和 <code>C5</code>）以及这两个分支的工作祖先（<code>C2</code>），做一个简单的三方合，如图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/basic-merging-1.png"></center>

<center>一次典型合并中所用到的三个快照</center>

<p>和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交，如图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/basic-merging-2.png"></center>

<center>一个合并提交</center>

<p>需要指出的是，Git 会自行决定选取哪一个提交作为最优的共同祖先，并以此作为合并的基础。Git 的这个优势使其在合并操作上比其他系统要简单很多。</p>
<p><strong><code>iss53</code>分支合并到<code>master</code>分支中（有冲突合并）</strong></p>
<p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 如果你对 #53 问题的修改和有关 <code>hotfix</code> 的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge iss53</span></span><br><span class="line">Auto-merging index.html</span><br><span class="line">CONFLICT (content): Merge conflict in index.html</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 <code>git status</code> 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run "git commit")</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use "git add &lt;file&gt;..." to mark resolution)</span><br><span class="line"></span><br><span class="line">    both modified:      index.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure>

<p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line">=======</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line"> please contact us at support@github.com</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure>

<p>这表示 <code>HEAD</code> 所指示的版本（也就是你的 <code>master</code> 分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支）在这个区段的上半部分（<code>=======</code> 的上半部分），而 <code>iss53</code> 分支所指示的版本在 <code>=======</code> 的下半部分。 为了解决冲突，你必须选择使用由 <code>=======</code> 分割的两部分中的一个，或者你也可以自行合并这些内容。 例如，你可以通过把这段内容换成下面的样子来解决冲突：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line">please contact us at email.support@github.com</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>上述的冲突解决方案仅保留了其中一个分支的修改，并且 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> , <code>=======</code> , 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 这些行被完全删除了。 在你解决了所有文件里的冲突之后，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。</p>
<p>如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 <code>git commit</code> 来完成合并提交。 默认情况下提交信息看起来像下面这个样子：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Merge branch 'iss53'</span><br><span class="line"></span><br><span class="line">Conflicts:</span><br><span class="line">    index.html</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> It looks like you may be committing a merge.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> If this is not correct, please remove the file</span></span><br><span class="line"><span class="meta">#</span><span class="bash">	.git/MERGE_HEAD</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> and try again.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Please enter the commit message <span class="keyword">for</span> your changes. Lines starting</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> with <span class="string">'#'</span> will be ignored, and an empty message aborts the commit.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> All conflicts fixed but you are still merging.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">	modified:   index.html</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br></pre></td></tr></table></figure>

<p>如果你觉得上述的信息不够充分，不能完全体现分支合并的过程，你可以修改上述信息，添加一些细节给未来检视这个合并的读者一些帮助，告诉他们你是如何解决合并冲突的，以及理由是什么。</p>
<h3 id="3-5-分支管理"><a href="#3-5-分支管理" class="headerlink" title="3.5 分支管理"></a>3.5 分支管理</h3><p>现在已经创建、合并、删除了一些分支，让我们看看一些常用的分支管理工具。</p>
<p><strong>查看所有分支</strong></p>
<p><code>git branch</code> 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">  iss53</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure>

<p>注意 <code>master</code> 分支前的 <code>*</code> 字符：它代表现在检出的那一个分支（也就是说，当前 <code>HEAD</code> 指针所指向的分支）。</p>
<p>如果需要查看每一个分支的最后一次提交，可以运行 <code>git branch -v</code> 命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -v</span></span><br><span class="line">  iss53   93b412c fix javascript issue</span><br><span class="line">* master  7a98805 Merge branch 'iss53'</span><br><span class="line">  testing 782fd34 add scott to the author list in the readmes</span><br></pre></td></tr></table></figure>

<p><strong>查看已经合并到当前分支的分支</strong></p>
<p>如果你要查看哪些分支已经合并到当前分支，可以运行 <code>git branch --merged</code>：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --merged</span></span><br><span class="line">  iss53</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<p>因为之前已经合并了 <code>iss53</code> 分支，所以现在看到它在列表中。 在这个列表中分支名字前没有 <code>*</code> 号的分支通常可以使用 <code>git branch -d</code> 删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。</p>
<p><strong>查看未合并到当前分支的分支</strong></p>
<p>如果你查看所有包含未合并工作的分支，可以运行 <code>git branch --no-merged</code>：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --no-merged</span></span><br><span class="line">  testing</span><br></pre></td></tr></table></figure>

<p>这里显示了其他分支。 因为它包含了还未合并的工作，尝试使用 <code>git branch -d</code> 命令删除它时会失败：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d testing</span></span><br><span class="line">error: The branch 'testing' is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run 'git branch -D testing'.</span><br></pre></td></tr></table></figure>

<p>如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用 <code>-D</code> 选项强制删除它。</p>
<h2 id="4-Git远程分支操作。"><a href="#4-Git远程分支操作。" class="headerlink" title="4. Git远程分支操作。"></a>4. Git远程分支操作。</h2><p>本节将主要介绍本地分支与远程分支之间的交互，而<strong>远程分支是远程引用的一部分，远程引用是对远程仓库的引用，包括分支、标签等</strong>，所以我们先介绍远程仓库的一些概念与操作，再介绍远程分支的操作。</p>
<h3 id="4-1-远程仓库"><a href="#4-1-远程仓库" class="headerlink" title="4.1 远程仓库"></a>4.1 远程仓库</h3><p>远程仓库即在远程服务器上的Git仓库，仓库中可能包含多个分支，我们可以通过添加远程仓库的方式来将一个远程仓库本地化。本节将分别介绍如何添加远程仓库，如何查看远程仓库的信息，如何从远程仓库中抓取(fetch)与拉取(pull)数据，如何从本地推送数据到远程仓库的远程分支上，以及如何重命名和移除远程仓库。<strong>在整个介绍过程中需要注意远程仓库的远程分支与本地分支的关系</strong>。</p>
<p><strong>添加远程仓库</strong></p>
<p>如果你想添加一个远程仓库，运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br><span class="line">origin</span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add pb https://github.com/paulboone/ticgit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line">origin	https://github.com/schacon/ticgit (fetch)</span><br><span class="line">origin	https://github.com/schacon/ticgit (push)</span><br><span class="line">pb	https://github.com/paulboone/ticgit (fetch)</span><br><span class="line">pb	https://github.com/paulboone/ticgit (push)</span><br></pre></td></tr></table></figure>

<p>现在你可以在命令行中使用字符串 <code>pb</code> 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 <code>git fetch pb</code>：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch pb</span></span><br><span class="line">remote: Counting objects: 43, done.</span><br><span class="line">remote: Compressing objects: 100% (36/36), done.</span><br><span class="line">remote: Total 43 (delta 10), reused 31 (delta 5)</span><br><span class="line">Unpacking objects: 100% (43/43), done.</span><br><span class="line">From https://github.com/paulboone/ticgit</span><br><span class="line"> * [new branch]      master     -&gt; pb/master</span><br><span class="line"> * [new branch]      ticgit     -&gt; pb/ticgit</span><br></pre></td></tr></table></figure>

<p>现在 Paul 的 master 分支可以在本地通过 <code>pb/master</code> 访问到。</p>
<p><strong>查看远程仓库</strong></p>
<p>如果想<strong>查看你已经配置的远程仓库服务器</strong>，可以运行 <code>git remote</code> 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin（这是 Git 给你克隆的仓库服务器的默认名字）：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/schacon/ticgit</span></span><br><span class="line">Cloning into 'ticgit'...</span><br><span class="line">remote: Reusing existing pack: 1857, done.</span><br><span class="line">remote: Total 1857 (delta 0), reused 0 (delta 0)</span><br><span class="line">Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (772/772), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ticgit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure>

<p>你也可以指定选项 <code>-v</code>，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line">origin	https://github.com/schacon/ticgit (fetch)</span><br><span class="line">origin	https://github.com/schacon/ticgit (push)</span><br></pre></td></tr></table></figure>

<p>如果你的远程仓库不止一个，该命令会将它们全部列出。</p>
<p>如果想要<strong>查看某一个远程仓库的更多信息</strong>，可以使用 <code>git remote show [remote-name]</code> 命令。 如果想以一个特定的缩写名运行这个命令，例如 <code>origin</code>，会得到像下面类似的信息：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote show origin</span></span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/schacon/ticgit</span><br><span class="line">  Push  URL: https://github.com/schacon/ticgit</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master                               tracked</span><br><span class="line">    dev-branch                           tracked</span><br><span class="line">  Local branch configured for 'git pull':</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured for 'git push':</span><br><span class="line">    master pushes to master (up to date)</span><br></pre></td></tr></table></figure>

<p>它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 master 分支，并且如果运行 git pull，就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。 它也会列出拉取到的所有远程引用。</p>
<p><strong>从远程仓库中抓取与拉取</strong></p>
<p>如果你想<strong>从远程仓库中抓取数据</strong>，可以执行<code>git fetch [remote-name]</code>，这个命令会访问远程仓库，将所有远程仓库中的远程分支更新到本地。 执行完成后，你将会拥有<strong>那个远程仓库中所有分支的引用</strong>，可以随时合并或查看。</p>
<p>如果你使用 <code>clone</code> 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。必须注意 <code>git fetch</code> 命令会<strong>将数据拉取到你的本地仓库，它并不会自动合并或修改你当前的工作，当准备好时你必须手动将其合并入你的工作。</strong></p>
<p>如果当前分支与远程分支存在追踪关系，<code>git pull</code>就可以省略远程分支名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin</span><br></pre></td></tr></table></figure>

<p>上面命令表示，本地的当前分支自动与对应的<code>origin</code>主机”追踪分支”(remote-tracking branch)进行合并。</p>
<p><strong>推送到远程仓库</strong></p>
<p>如果你想<strong>将本地项目推送到远程仓库</strong>，你可以运行命令<code>git push [remote-name] [branch-name]</code>。 例如，当你想要将 master 分支推送到 <code>origin</code> 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到远程仓库：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin master</span></span><br></pre></td></tr></table></figure>

<p>*<em>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 *</em>当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。</p>
<p><strong>远程仓库的重命名与移除</strong></p>
<p>如果想要<strong>重命名引用的名字</strong>可以运行 <code>git remote rename</code> 去修改一个远程仓库的简写名。 例如，想要将 <code>pb</code> 重命名为 <code>paul</code>，可以用 <code>git remote rename</code> 这样做：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote rename pb paul</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure>

<p>值得注意的是这同样也会修改你的远程分支名字。 那些过去引用 <code>pb/master</code> 的现在会引用 <code>paul/master</code>。</p>
<p>如果因为一些原因想要<strong>移除一个远程仓库</strong> ，你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了 - 可以使用 <code>git remote rm</code> ：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote rm paul</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure>

<h3 id="4-2-远程分支"><a href="#4-2-远程分支" class="headerlink" title="4.2 远程分支"></a>4.2 远程分支</h3><p>远程分支指在远程仓库中的分支，而我们在将远程仓库中的远程分支通过抓取数据命令本地化后，Git都会为远程分支创建<strong>远程追踪分支</strong>。远程追踪分支是不能移动的本地引用，以 <code>(remote)/(branch)</code> 形式命名，当我们做任何网络通信操作时，它们会自动移动。本节将介绍如何添加远程分支，如何追踪远程分支，如何查看追踪分支信息，如何把本地分支推送到远程分支，以及如何删除远程分支。</p>
<p><strong>添加远程分支</strong></p>
<p>如果我们要从远程仓库的远程分支上抓取数据一般会通过两种方式：<code>git fetch</code>和<code>git pull</code>。</p>
<p>如果我们要从远程仓库抓取某个分支的数据，可以运行<code>git fetch [remote-name] [branch-name]</code>命令。 例如，运行<code>git fetch origin master</code>命令，你可以将远程仓库<code>origin</code>上的<code>master</code>分支抓取下来，Git会在本地新建一个<code>origin/master</code>远程追踪分支，但不会自动与本地分支合并。</p>
<p>如果我们想在<code>origin/master</code>基础上进行工作，就需要一个本地分支来追踪<code>origin/master</code>分支。如何追踪？下文将介绍。</p>
<p>有时，先利用<code>git fetch</code>命令再利用本地分支进行追踪会嫌麻烦，我们可以利用<code>git pull</code>命令进行简化。例如，运行<code>git pull origin master</code>命令，Git会在本地新建一个<code>origin/master</code>远程追踪分支，并且会自动创建本地分支<code>master</code>来追踪<code>origin/master</code>分支。</p>
<p><em>git fetch和git pull的区别</em></p>
<p><em>git fetch</em>：相当于是从远程获取最新版本到本地，不会自动合并。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin master</span><br><span class="line">$ git log -p master..origin/master</span><br><span class="line">$ git merge origin/master</span><br></pre></td></tr></table></figure>

<p>以上命令的含义：</p>
<ul>
<li>首先从远程的<code>origin</code>的<code>master</code>主分支下载最新的版本到<code>origin/master</code>分支上</li>
<li>然后比较本地的<code>master</code>分支和<code>origin/master</code>分支的差别</li>
<li>最后进行合并</li>
</ul>
<p>上述过程其实可以用以下更清晰的方式来进行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin master:tmp</span><br><span class="line">$ git diff tmp </span><br><span class="line">$ git merge tmp</span><br></pre></td></tr></table></figure>

<p> <em>git pull</em>：相当于是从远程获取最新版本并<code>merge</code>到本地 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin master</span><br></pre></td></tr></table></figure>

<p>上述命令其实相当于<code>git fetch</code> 和 <code>git merge</code>两个命令。</p>
<p>在实际使用中，<code>git fetch</code>更安全一些，因为在<code>merge</code>前，我们可以查看更新情况，然后再决定是否合并。</p>
<p><strong>追踪分支</strong></p>
<p>我们可以自己创建一个本地分支，然后将本地分支与远程追踪分支进行合共来追踪远程分支。我们可以运行 <code>git checkout -b [branch] [remotename]/[branch]</code>来完成以上操作， 这是一个十分常用的操作，所以 Git 提供了 <code>--track</code> 快捷方式：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout --track origin/serverfix</span></span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch 'serverfix'</span><br></pre></td></tr></table></figure>

<p>如果想要将本地分支与远程分支设置为不同名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b sf origin/serverfix</span></span><br><span class="line">Branch sf set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch 'sf'</span><br></pre></td></tr></table></figure>

<p>现在，本地分支 <code>sf</code> 会自动从 <code>origin/serverfix</code> 拉取。</p>
<p><strong>查看追踪分支信息</strong></p>
<p>如果想要<strong>查看设置的所有跟踪分支</strong>，可以使用 <code>git branch</code> 的 <code>-vv</code> 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -vv</span></span><br><span class="line">  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets</span><br><span class="line">  master    1ae2a45 [origin/master] deploying index fix</span><br><span class="line">* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it</span><br><span class="line">  testing   5ea463a trying something new</span><br></pre></td></tr></table></figure>

<p>这里可以看到 <code>iss53</code> 分支正在跟踪 <code>origin/iss53</code> 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 <code>master</code> 分支正在跟踪 <code>origin/master</code> 分支并且是最新的。 接下来可以看到 <code>serverfix</code> 分支正在跟踪 <code>teamone</code> 服务器上的 <code>server-fix-good</code> 分支并且领先 3 落后 1，意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 <code>testing</code> 分支并没有跟踪任何远程分支。</p>
<p><strong>推送本地分支到远程分支</strong></p>
<p>如果当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步 ，你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。</p>
<p>例如，如果你希望和别人一起在名为 <code>serverfix</code> 的分支上工作，可以推送<strong>第一个</strong>分支，运行 <code>git push [remot-name] [branch-name]</code>:</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin serverfix</span></span><br><span class="line">Counting objects: 24, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (15/15), done.</span><br><span class="line">Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.</span><br><span class="line">Total 24 (delta 2), reused 0 (delta 0)</span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line"> * [new branch]      serverfix -&gt; serverfix</span><br></pre></td></tr></table></figure>

<p>这里有些工作被简化了。 Git 自动将 <code>serverfix</code> 分支名字展开为 <code>refs/heads/serverfix:refs/heads/serverfix</code>，那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。” 如果并不想让远程仓库上的分支叫做 <code>serverfix</code>，可以运行 <code>git push origin serverfix:awesomebranch</code> 来将本地的 <code>serverfix</code> 分支推送到远程仓库上的 <code>awesomebranch</code> 分支。</p>
<p>当然，如果远程仓库中已存在<code>severfix</code>分支，则推送就会出现冲突，需要先将<code>severfix</code>抓取下来，与本地分支合并之后，再进行推送。</p>
<p><strong>删除远程分支</strong></p>
<p>如果你已经通过远程分支做完所有的工作了 ，例如，你和你的协作者已经完成了一个特性并且将其合并到了远程仓库的 <code>master</code> 分支。可以运行带有 <code>--delete</code> 选项的 <code>git push</code> 命令来删除一个远程分支。 例如，想要从服务器上删除 <code>serverfix</code> 分支，运行下面的命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete serverfix</span></span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line"> - [deleted]         serverfix</span><br></pre></td></tr></table></figure>

<p>基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要是摘抄及整理了两个教程的文字，通过三个层次（单分支、多分支及远程分支）来介绍Git的概念及使用。首先，在不讨论分支概念的情况下，介绍单分支场景下的文件操作；然后，在本地环境下，介绍多分支的分支操作；最后，加入远程仓库，介绍远程分支与本地分支的交互。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">git官方教程</a></p>
<p><a href="https://www.yiibai.com/git/" target="_blank" rel="noopener">git易百教程</a></p>
</center>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/15/Git入门笔记/" data-id="ck0kz0noi0004kst0xiafy70u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/09/15/JVM笔记（理论篇）/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          JVM 笔记（理论篇）
        
      </div>
    </a>
  
  
    <a href="/2019/09/15/数据结构与算法（剑指offer）/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">数据结构与算法（剑指offer）</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/15/SSH基本原理/">SSH 基本原理</a>
          </li>
        
          <li>
            <a href="/2019/09/15/JVM笔记（理论篇）/">JVM 笔记（理论篇）</a>
          </li>
        
          <li>
            <a href="/2019/09/15/Git入门笔记/">Git 入门笔记</a>
          </li>
        
          <li>
            <a href="/2019/09/15/数据结构与算法（剑指offer）/">数据结构与算法（剑指offer）</a>
          </li>
        
          <li>
            <a href="/2019/09/15/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Zhou Jianbo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>