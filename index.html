<!DOCTYPE html>
<html>
<<<<<<< HEAD
<head><meta name="generator" content="Hexo 3.9.0">
=======
<head>
>>>>>>> origin/master
  <meta charset="utf-8">
  

  
<<<<<<< HEAD
  <title>DevelopInfo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="DevelopInfo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="DevelopInfo">
<meta property="og:locale" content="zh">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DevelopInfo">
  
    <link rel="alternate" href="/atom.xml" title="DevelopInfo" type="application/atom+xml">
=======
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
>>>>>>> origin/master
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
<<<<<<< HEAD
</html>
=======

>>>>>>> origin/master
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
<<<<<<< HEAD
        <a href="/" id="logo">DevelopInfo</a>
=======
        <a href="/" id="logo">Hexo</a>
>>>>>>> origin/master
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
<<<<<<< HEAD
    <article id="post-SSH基本原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/15/SSH基本原理/" class="article-date">
  <time datetime="2019-09-15T12:43:26.899Z" itemprop="datePublished">2019-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/15/SSH基本原理/">SSH 基本原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SSH-基本原理"><a href="#SSH-基本原理" class="headerlink" title="SSH 基本原理"></a>SSH 基本原理</h1><h2 id="SSH-是什么？"><a href="#SSH-是什么？" class="headerlink" title="SSH 是什么？"></a>SSH 是什么？</h2><p>SSH 为 <a href="https://baike.baidu.com/item/Secure%20Shell" target="_blank" rel="noopener">Secure Shell</a> 的缩写，由 IETF 的网络小组（Network Working Group）所制定。SSH是一种用于安全访问远程服务器的网络协议。它将客户端与服务端之间的消息通过加密保护起来，这样就无法被窃取或篡改了。那么它安全性是如何实现的呢？</p>
<p>本文我们将主要讨论SSH服务是如何工作的以及SSH协议的组成，以理解SSH的基本原理。</p>
<h2 id="SSH是如何工作的？"><a href="#SSH是如何工作的？" class="headerlink" title="SSH是如何工作的？"></a>SSH是如何工作的？</h2><p>在理解本节将主要讨论SSH是如何工作的。SSH服务主要是基于Client-Server架构，工作过程主要包含<strong>会话建立</strong>和<strong>之后的数据通信</strong>。本节将主要介绍SSH服务的会话建立过程，数据通信过程主要是利用对称加密方式对数据进行加密传输。</p>
<p>SSH服务<strong>会话(Session)的建立</strong>（不包括数据传输阶段）主要包含两个阶段。<strong>第一阶段</strong>，Client与Server之间需要协商会话加密相关的事务，包括协议版本号协商、密钥协商等；<strong>第二阶段</strong>，当加密会话建立之后，Server需要验证Client用户是否是合法用户。</p>
<p>下图显示了一个简化后的会话建立过程。</p>
<p><img src="http://zhoujianbo.gitee.io/notes/pics/SSH/how-does-ssh-protocol-work-920x272-SWKuhzNV.png" alt="a simplified setup flow of a secure shell connection"></p>
<p><strong>首先</strong>，客户端发送连接请求给服务器，服务器返回它所支持的协议版本号，如果客户端支持其中一种协议版本，则连接继续进行。同时，服务器会发送它的public host key，客户端利用该公钥检查是不是自己想连接的服务器主机（如何检查？用户人眼检查，客户端会发送一段警告，用户自行判断是否是合法服务器发来的公钥）。</p>
<p><strong>接着</strong>，双方需要协商出一个<strong>会话密钥（Session Key）</strong>。如何协商？利用一种叫Diffie-Hellman 的算法（这里不详述，可参考<a href="https://www.digitalocean.com/community/tutorials/understanding-the-ssh-encryption-and-connection-process" target="_blank" rel="noopener">Understanding the SSH Encryption and Connection Process</a>）。session key 有何用？服务器与客户端之后的所有通信数据都会利用 对称加密方式，利用 session key 进行加密和解密。</p>
<p><strong>当加密会话建立之后</strong>，下面开始进行用户身份验证阶段。为什么要进行用户验证？<strong>个人理解</strong>，在会话建立之后，客户端完成对服务器的认证，而服务器并未认证客户端的访问权限，因此需要用户验证过程。最常用的两种验证方式为密码登录验证和公钥验证。</p>
<p><strong>密码登录验证</strong>，客户端发送用户名和密码给服务器，服务器对其进行认证。其中，用户名与密码的传输会利用 session key 进行加密，该过程是对称加密。由于用户密码过简单会存在被破译的风险，密码验证方式并不推荐。</p>
<p><strong>公钥验证</strong>，该验证过程会利用到非对称加密方式，验证过程如下：</p>
<ol>
<li>客户端发送自己的公钥给服务器，服务器在认证公钥表 authorized_keys 中寻找该公钥（因此，用户需要事先将公钥分享给服务器，例如：github上用户手动粘贴公钥给github服务器）。如果公钥不存在，则认证失败；如果公钥存在，服务器会形成一个随机数并且利用该公钥进行加密，形成一段加密信息。</li>
<li>服务器将加密信息发送给客户端，客户端利用私钥进行解密，解密出服务器生成的随机数。客户端将解密出的随机数即利用 session key 进行加密，然后计算加密后数的MD5值。</li>
<li>客户端将生成的MD5值发送给服务器，服务器会将之前生成的随机数利用 session key 进行加密，并计算加密后数的MD5值。然后将客户端发送来的值与计算出的值进行比对，如果两个值匹配，则验证成功。</li>
</ol>
<p>可以看出，公钥验证方式服务器可以利用客户端公钥验证客户端的合法性。</p>
<p><strong>当用户验证阶段结束之后</strong>，服务器和客户端就可以利用对称加密的方式进行数据通信，对称加密的密钥为 session key。会话结束的时候，session key 会被销毁，下一次连接又会生成一个全新的 session key。</p>
<h2 id="SSH-的组成是什么？"><a href="#SSH-的组成是什么？" class="headerlink" title="SSH 的组成是什么？"></a>SSH 的组成是什么？</h2><p>本节主要参考<a href="https://tools.ietf.org/html/rfc4251#page-17" target="_blank" rel="noopener">rfc4251</a>文件，同时加入个人理解进行阐述，如有不正确的理解，希望读者指出。</p>
<p>SSH协议主要包含三层协议传输协议（Transport Protocol）、认证协议（Authentication Protocol）以及 连接协议（Connection Protocol）。</p>
<p><strong>Transport Protocol</strong></p>
<p>传输协议主要作用是在不安全的网络中提供一个受信任的加密（confidential）通道。该层协议需要完成服务器主机认证(server host authentication)，key 交换(key exchange)，加密(encryption)以及完整性保护(integrity protection)；同时，该层协议会产生一个特有的会话标识(session id)以提供给上层协议调用。</p>
<p>传输协议的存在，个人理解，主要是需要解决在建立安全通道的过程中的许多安全漏洞，以初始化一个安全的会话连接。其中，比较重要的安全问题–中间人攻击问题，本节将主要讨论SSH如何预防中间人攻击(man-in-the- middle attacks)。</p>
<p>三种中间人攻击的情况：</p>
<p>（1）第一种情况发生在Client与Server建立会话之前，中间人伪装为合法的Server，发送自己的公钥(public key)给Client；同时，中间人伪装为Client，发送初始化会话(session)请求。</p>
<p>对于第一种情况，SSH如何应对呢？如果Server（不知是中间人还是合法服务器）发送的公钥在会话初始化之前就已经存储在Client中，则SSH认为该公钥为合法Server的公钥；如果该公钥没有事先存储在Client中，则SSH会发送一段警告，让用户自行决定是否接受该公钥，并继续会话(session)操作。</p>
<p>（2）（个人理解）第二种情况与第一种情况相似，中间人可以模仿合法Server发送自己的公钥给Client，根据第一种情况的解决方案，当公钥是第一次被Client接收到时，Client需要用户自行判别公钥的可信度，而这样是不够安全的。</p>
<p>对于第二种情况，SSH协议是建议（可以有不同的实现）可以利用一个可信赖的中间认证机构(Certification Authority, CA)来认证Server公钥，Client可以向认证机构提交认证申请；同时，也可以在Client中分配一个认证数据数据库，来认证公钥是否是合法Server发送的。这样以实现Server公钥的安全分发。</p>
<p>（3）第三种情况发生在Client与Server建立会话之后，中间人可以在数据传输过程中操纵数据包。</p>
<p>对于第三种情况，如果MAC(Message Authentication Codes)算法是安全的，这种情况的攻击是不可能的。因此，SSH协议是建议利用现存安全的MAC算法。</p>
<p>当然，传输协议还有许多其他标准规定，这里不详细介绍。</p>
<p><strong>Authentication Protocol</strong></p>
<p>认证协议主要作用是提供一组机制来认证客户端用户是否可以连接服务器。<strong>个人理解</strong>，在传输协议(Transport Protocol)之后，Client已经认证完Server主机，并且建立起一个安全的会话，但Server并没有认证Client的访问权限，这就需要认证协议来规定Server认证Client的过程。</p>
<p>用户认证的实现有很多，不过目前两种主流方式为：密码登录验证和公钥验证。</p>
<p><strong>Connection Protocol</strong></p>
<p>连接协议主要作用是指定一种安全机制在confidential和authenticated传输过程中复用多个数据流/通道。如何进行多路复用的，这里讲不进行阐述。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍SSH服务的工作流程，并初探SSH协议的组成。个人总结，SSH服务中有两个重要过程，一个是会话协商过程，另一个是用户认证过程，这两个过程便是SSH服务会话建立的主要过程，之后的数据传输过程主要是利用 session key 进行对称加密。SSH协议的组成是为了更好的理解SSH服务的工作过程，协议的制定需要考虑很多因素，本文主要是简单讨论了 Transport Protocol 中考虑的中间人攻击问题，个人认为这就是需要进行服务器认证的原因；Authentication Protocol 中主要是考虑用户验证问题；Connection Protocol 中的标准，个人很少会运用到，本文便没再讨论。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://tools.ietf.org/html/rfc4251#page-17" target="_blank" rel="noopener">rfc4251</a></p>
<p><a href="https://www.digitalocean.com/community/tutorials/understanding-the-ssh-encryption-and-connection-process" target="_blank" rel="noopener">Understanding the SSH Encryption and Connection Process</a></p>
<p><a href="http://erik-2-blog.logdown.com/posts/74081-ssh-principle" target="_blank" rel="noopener">SSH是如何防御重放攻击的？</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/15/SSH基本原理/" data-id="ck0kz0nns0001kst0x9dcpgsf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JVM笔记（理论篇）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/15/JVM笔记（理论篇）/" class="article-date">
  <time datetime="2019-09-15T12:43:26.885Z" itemprop="datePublished">2019-09-15</time>
=======
    <article id="post-The-understanding-and-realization-of-DNC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/30/The-understanding-and-realization-of-DNC/" class="article-date">
  <time datetime="2018-05-30T07:26:51.000Z" itemprop="datePublished">2018-05-30</time>
>>>>>>> origin/master
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
<<<<<<< HEAD
      <a class="article-title" href="/2019/09/15/JVM笔记（理论篇）/">JVM 笔记（理论篇）</a>
=======
      <a class="article-title" href="/2018/05/30/The-understanding-and-realization-of-DNC/">The understanding and realization of DNC</a>
>>>>>>> origin/master
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
<<<<<<< HEAD
        <h1 id="JVM笔记（理论篇）"><a href="#JVM笔记（理论篇）" class="headerlink" title="JVM笔记（理论篇）"></a>JVM笔记（理论篇）</h1><p>[TOC]</p>
<p>本笔记主要是记录Java虚拟机中的一些知识要点，并尽力阐述清楚各个知识点之间的联系。对于每一个Java类，Java编译器首先将其编译成对应的Class文件；在运行程序阶段，Java虚拟机会加载Class文件中的数据进行运行；在程序运行过程中，Java虚拟机会对实例对象进行内存分配以及垃圾回收。因此本文将主要介绍：<strong>Class文件结构，类加载机制，以及垃圾回收与内存分配机制。</strong></p>
<h2 id="1-Class文件结构"><a href="#1-Class文件结构" class="headerlink" title="1. Class文件结构"></a>1. Class文件结构</h2><p>一个java类会被Java编译器编译成一个Class文件，打开Class文件会发现是二进制文件，那每个二进制位表示什么含义呢？本节将介绍Class文件的结构。Class文件是一组以字节（8bit）为基础单位的二进制文件，各个数据项目严格按照顺序排列，形成Class文件。每个数据项目都有其数据类型，决定了该数据项目所占的字节数量。数据项目共有两个数据类型：<strong>无符号数和表</strong>，例如：数据类型u2表示一个占用2个字节的数据项目，数据项目表示一个无符号数；数据类型cp_info表示一个常量池表类型的数据项目，数据项目表示一个常量池表，cp_info表相当于一个结构体，在表中定义了其他属性。Class文件是一个将固定的数据项目按照固定的顺序排列的二进制文件，文件结构如下表所示：</p>
<center>表：Class文件结构/格式</center>

<table>
<thead>
<tr>
<th>数据类型</th>
<th>数据项目/名称</th>
<th>数量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>u4</td>
<td>magic</td>
<td>1</td>
<td>魔数，它的唯一作用就是告诉虚拟机是否是一个Class文件。</td>
</tr>
<tr>
<td>u2</td>
<td>minor_version</td>
<td>1</td>
<td>次版本号</td>
</tr>
<tr>
<td>u2</td>
<td>major_version</td>
<td>1</td>
<td>主版本号</td>
</tr>
<tr>
<td>u2</td>
<td>constant_pool_count</td>
<td>1</td>
<td>常量池大小</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool</td>
<td>constant_pool_count-1</td>
<td>常量池，里面存储着<strong>字面量</strong>和<strong>符号引用</strong>。（稍后解释）</td>
</tr>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
<td>访问标志，用于识别类或接口层次的一些修饰信息。</td>
</tr>
<tr>
<td>u2</td>
<td>this_class</td>
<td>1</td>
<td>类索引，存储的地址指向该类在常量池中所对应的<strong>类型为CONSTANT_CLASS_INFO的类描述符常量</strong>。</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
<td>1</td>
<td>继承的父类索引，存储的地址指向父类在常量池中所对应的<strong>类型为CONSTANT_CLASS_INFO的类描述符常量</strong>。</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
<td>1</td>
<td>实现的接口数量</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces</td>
<td>interfaces_count</td>
<td>接口索引，存储的地址指向实现的接口在常量池中所对应的常量。</td>
</tr>
<tr>
<td>u2</td>
<td>fields_count</td>
<td>1</td>
<td>字段数量</td>
</tr>
<tr>
<td>field_info</td>
<td>fields</td>
<td>fields_count</td>
<td>字段表</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count</td>
<td>1</td>
<td>方法数量</td>
</tr>
<tr>
<td>method_info</td>
<td>method2</td>
<td>methods_count</td>
<td>方法表</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
<td>属性数量</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
<td>属性表</td>
</tr>
</tbody></table>
<p>第一项<strong>魔数</strong>，它的唯一作用就是告诉虚拟机是否是一个Class文件。</p>
<p>第二项<strong>次版本及主版本号</strong>，存储着jdk的主次版本号，JDK1.0的主版本号是45，其他版本号在此基础上+1，例如，jdk1.7主版本号为51。</p>
<p>第三项<strong>常量池大小及常量池</strong>，常量池大小存储着常量池中常量的数量，即cp_info类型数据项目的数量。常量池中主要存放两大类常量：<strong>字面量（Literal）和符号引用（Symbolic References）。</strong>字面量是指Java语言中的常量，例如：文本字符串、声明为final的常量值等。符号引用包括三类常量：类和接口的全限定名（例如：java.lang.Object）、字段的名称（例如：a）和描述符（例如：int）、方法的名称和描述符。在JDK1.7之后，常量池共包含17中数据类型的常量，每个数据类型的结构都不一样。</p>
<p>第四项<strong>访问标志</strong>，用于识别类或接口层次的一些修饰信息。例如：这个Class是类还是接口；如否定义为public类型；是否定义为abstract类型等。</p>
<p>第五项<strong>类索引、父类索引与接口集合</strong>，类索引存储的地址指向该类在常量池中所对应的<strong>类型为CONSTANT_CLASS_INFO的类描述符常量</strong>；继承的父类索引，存储的地址指向父类在常量池中所对应的<strong>类型为CONSTANT_CLASS_INFO的类描述符常量</strong>；接口集合包含接口的数量和多个实现的接口索引。</p>
<p>第六项<strong>字段表集合</strong>，字段表集合包括字段数量和多个字段表。<strong>字段表（field_info）</strong>用于描述接口或类中声明的变量，字段（field）包括类级变量（例如：public static int a = 0；那么a属于类级变量）和实例级变量（例如：public int o = 1; 那么o属于实例级变量），不包括在方法内部声明的局部变量。那么，一个字段如何描述呢？字段应该包含从4个层面描述：第一，字段修饰符（例如：public or private, static or not, final or not, volatile or not, transient or not）；第二，字段数据类型（基本类型，引用类型还是数组）；第三，字段名称；第四，额外的属性信息。第一个层次的信息可以利用标志位进行标记；而第二第三层信息存在信息不固定的特点，则可以引用常量池中的常量进行描述；同时，字段可能会产生一些额外信息（例如，final static int m=123;那就会存在一项名为ConstantValue的属性），则可以利用属性表进行描述。因此字段表的结构如下表所示：</p>
<center>表：字段表结构</center>

<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">数据项目/名称</th>
<th align="center">数量</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">access_flags</td>
<td align="center">1</td>
<td align="center">修饰符标记</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">name_index</td>
<td align="center">1</td>
<td align="center">字段名称的索引</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">descriptor_index</td>
<td align="center">1</td>
<td align="center">字段描述符的索引</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">attributes_count</td>
<td align="center">1</td>
<td align="center">属性的数量</td>
</tr>
<tr>
<td align="center">attribute_info</td>
<td align="center">attributes</td>
<td align="center">attributes_count</td>
<td align="center">属性信息</td>
</tr>
</tbody></table>
<p>第七项<strong>方法表集合</strong>，方法表集合包括方法数量和多个方法表。方法表用以描述类中各个方法的信息，方法的描述类似字段的描述，因此方法表的结构与字段表的结构相同。</p>
<p>第八项<strong>属性表集合</strong>，属性集合包括属性数量和多个属性表，用以描述一些额外信息。属性集合在Class文件、字段表和方法表中都可以携带。在java虚拟机规范中预定了21个属性，例如：存在于方法表中的Code属性，存在于字段表中的ConstantValue属性，使用在类文件中的InnerClasses属性。对于每个属性，可以通过属性名和属性值来描述，属性名可以引用常量池中的常量来表示，属性值可以利用属性值长度和自定义的属性值结构来表示，因此属性表的结构如下表所示：</p>
<center>表：属性表结构</center>

<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">数据项目/名称</th>
<th align="center">数量</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">attribute_name_index</td>
<td align="center">1</td>
<td align="center">属性名称的索引</td>
</tr>
<tr>
<td align="center">u4</td>
<td align="center">attribute_length</td>
<td align="center">1</td>
<td align="center">属性值的长度</td>
</tr>
<tr>
<td align="center">u1</td>
<td align="center">info</td>
<td align="center">attribute_length</td>
<td align="center">属性值</td>
</tr>
</tbody></table>
<p>例如，Code属性表的结构如下表所示：</p>
<center>表：Code属性表结构</center>

<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">数据项目/名称</th>
<th align="left">数量</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">u2</td>
<td align="left">attribute_name_index</td>
<td align="left">1</td>
<td align="left">属性名称的索引</td>
</tr>
<tr>
<td align="left">u4</td>
<td align="left">attribute_length</td>
<td align="left">1</td>
<td align="left">属性值的长度</td>
</tr>
<tr>
<td align="left">u2</td>
<td align="left">max_stack</td>
<td align="left">1</td>
<td align="left">c操作数栈深度的最大值</td>
</tr>
<tr>
<td align="left">u2</td>
<td align="left">max_locals</td>
<td align="left">1</td>
<td align="left">j局部变量表所需的存储空间</td>
</tr>
<tr>
<td align="left">u4</td>
<td align="left">code_length</td>
<td align="left">1</td>
<td align="left">字节码长度</td>
</tr>
<tr>
<td align="left">u1</td>
<td align="left">code</td>
<td align="left">code_length</td>
<td align="left">用于存储字节码指令的字节流</td>
</tr>
<tr>
<td align="left">u2</td>
<td align="left">exception_tab_len</td>
<td align="left">1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">exception_info</td>
<td align="left">exception_table</td>
<td align="left">exception_tab_len</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">u2</td>
<td align="left">attributes_count</td>
<td align="left">1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">attribute_info</td>
<td align="left">attributes</td>
<td align="left">attributes_count</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>由于直接阅读Class文件的二进制流会非常繁琐，Oracle公司提供了javap工具，该工具可以对Class文件进行反编译，生成可阅读的Class文件</p>
<h2 id="2-类加载机制"><a href="#2-类加载机制" class="headerlink" title="2. 类加载机制"></a>2. 类加载机制</h2><p>上节介绍了Class文件的结构，Class文件中的数据项目最终都需要加载到虚拟机中才能运行。而虚拟机在何时对Class文件中的数据项目进行加载？虚拟机如何加载这些Class文件？Class文件中的数据项目进入到虚拟机后会发生什么变化？本节将对其进行介绍。</p>
<h3 id="2-1-类加载过程"><a href="#2-1-类加载过程" class="headerlink" title="2.1 类加载过程"></a>2.1 类加载过程</h3><p>类从被加载到虚拟机内存中到卸载出内存，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备和解析统称为连接（Linking），类的生命周期如图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/JVM/classLife.png"></center>

<center>类的生命周期</center>

<p>加载、验证、准备、初始化和卸载这5个阶段的<strong>开始</strong>顺序是确定的，而解析阶段有时在初始化阶段之后，这是为了java的动态绑定机制。</p>
<p><strong>类的加载时机</strong></p>
<p>那一个类或接口在何时进行加载呢？Java虚拟机规范没有强制规定，但对于初始化阶段（则加载、验证、准备自然要在其之前开始），虚拟机规范进行了明确规定：当一个类被<strong>主动引用</strong>时，会触发类的初始化操作（注意：<strong>初始化的是类变量，而不是实例变量</strong>）。那什么情况下会属于主动引用呢？主动引用包含5种情况：</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有初始化，则需要先初始化。遇到该情况最常见的场景：使用new关键字实例化一个对象；读取或设置一个静态字段（<strong>被final修饰、已在编译器吧结果放入常量池的静态字段除外</strong>）；以及调用静态方法。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用时，如果类没有初始化，则需要先初始化。</li>
<li>初始化一个类时，如果其父类没有初始化，则需要先初始化其父类。</li>
<li>虚拟机启动时，主类（包含main方法的类）会先初始化。</li>
<li>（不懂）使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后解析的结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄所对应类没有进行过初始化，则需要先初始化。</li>
</ol>
<p>除了主动引用的情况，其他情况下（称为被动引用）引用类，都不能够触发初始化操作。</p>
<p><strong>类的加载过程</strong></p>
<p>上节介绍了类的加载时机，那么虚拟机是如何加载类的呢？由于类的7个生命周期中，使用和卸载是不属于类的加载过程，本节将主要介绍加载、验证、准备、解析以及初始化过程。</p>
<p><strong>加载</strong>，该过程虚拟机主要完成3件事情：</p>
<ol>
<li>通过类的限定名获取该类的二进制流。虚拟机规范没有规定利用何种方式进行获取，因此可以从ZIP包中读取；从网络中获取；在运行时生成，例如动态代理技术；…</li>
<li>将字节流所代表的静态存储结构（个人理解为Class文件中存储的数据项目）转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象（虚拟机规范并没有规定实在堆区还是方法区中，HotSpot是存放在方法区里的），作为方法区的访问入口（例如，当执行MyClass myClass = new MyClass() 程序时，虚拟机首先找到 myClass类对象，然后通过类对象访问方法区中MyClass类的元数据信息）。</li>
</ol>
<p>对于非数组类的加载过程，开发人员可以通过类加载器进行加载；而对于<strong>数组类</strong>，它并不通过类加载器进行创建，它是由虚拟机直接创建的，但数组中的元素（Element，指数组去掉所有维度的类型）是要靠类加载器进行创建的。类加载器将在之后进行介绍。</p>
<p><strong>验证</strong>，该过程主要是确保Class文件中的字节流符合虚拟机规范，不会危害到虚拟机安全。例如需要进行文件格式验证、元数据验证（例如判断是否可继承等）、字节码验证（对类的方法进行校验）、符号引用验证等。</p>
<p><strong>准备</strong>，该过程主要是为<strong>类变量</strong>（即静态变量，并非类的实例对象）设置初始值，这些变量一般都存储在方法区。</p>
<p><strong>解析</strong>，该过程主要是将符号引用转化为直接引用。<strong>符号引用</strong>是用一组符号（任何形式的字面量）来定位目标；<strong>直接引用</strong>是用目标的地址来定位目标的。</p>
<p><strong>初始化</strong>，之前准备阶段已经对类变量进行了一次默认初始值这只，而该过程将通过执行类中定义的程序代码来初始化类变量，即在初始化阶段将执行类构造器<code>&lt;cinit&gt;()</code>（区别于类的实例构造器<code>&lt;init&gt;()</code>），下面介绍一下<code>&lt;cinit&gt;()</code>的执行细节：</p>
<ol>
<li><p><code>&lt;cinit&gt;()</code>的执行顺序是静态变量和静态语句块在源文件中出现的顺序，静态语句块可以在静态变量之前对其进行赋值，但不能进行访问。如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>; <span class="comment">//给变量进行赋值可以通过</span></span><br><span class="line">        System.out.println(i); <span class="comment">//编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>虚拟机会保证父类的<code>&lt;cinit&gt;()</code>方法在子类<code>&lt;cinit&gt;()</code>方法执行之前执行。这意味着父类中的静态语句会先于子类中的静态语句执行。如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> init A = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		A = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(B);<span class="comment">//输出2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果类中没有对静态变量赋值，并且也没有静态语句块，则编译器可以不为该类生成<code>&lt;cinit&gt;()</code>方法。</p>
</li>
<li><p>接口与类不同，接口的<code>&lt;cinit&gt;()</code>方法执行时，不需要先执行父接口的<code>&lt;cinit&gt;()</code>方法；同时，接口的实现类在初始化时也不需要执行接口的<code>&lt;cinit&gt;()</code>方法。</p>
</li>
<li><p>在多线程环境下，虚拟机会保证<code>&lt;cinit&gt;()</code>方法被正确地加锁和同步。如果有多个线程同时去初始化一个类，那么只会有一个线程去执行<code>&lt;cinit&gt;()</code>方法，其他线程需要阻塞等待。</p>
</li>
</ol>
<h3 id="2-2-类加载器"><a href="#2-2-类加载器" class="headerlink" title="2.2 类加载器"></a>2.2 类加载器</h3><p>在类的加载阶段，虚拟机所做的第一件事是:<strong>通过类的全限定名来获取该类的二进制字节流</strong>，如何去获取类的二进制字节流，开发人员可以利用<strong>类加载器</strong>完成这个动作。</p>
<p><strong>注意</strong>，对于任意一个类，在虚拟机中的唯一性是由加载它的类加载器和类本身一同决定的，每个类加载器都有一个独立的类命名空间。</p>
<p><strong>双亲委派模型</strong></p>
<p>类加载器可以分为2种类型：一种是启动类加载器（Bootstrap ClassLoader），它虚拟机自身的一部分，由c++语言实现；另一种是由java语言实现，并且继承自抽象类java.lang.ClassLoader。从开发人员的角度，类加载器可以分为3种：</p>
<ol>
<li>启动类加载器（Bootstrap ClassLoader），该加载器负责加载<java_home>\lib目录中的，或者是被-Xbootclasspath参数所指定的路径中的，并且能被虚拟机识别的（如rt.jar，名字不符合的不会被加载）类库。</java_home></li>
<li>扩展类加载器（Extension ClassLoader），该加载器负责加载<java_home>/lib目录中的，或者被java.ext.dirs系统变量所指定的路径中的类库。该加载器由sun.misc.Launcher$ExtClassLoader实现。</java_home></li>
<li>应用类加载器（Application ClassLoader），该加载器负责加载用户类路径（ClassPath）上的类库。该加载器由sum.misc.Launcher$ApplicationClassLoader实现。如果应用程序没有自定义类加载器，一般默认类加载器就是应用类加载器。</li>
</ol>
<p>如有必要，开发人员可以自定义类加载器。而这4种类加载器是有一定的调用层次关系的，称为<strong>双亲委派模型</strong>，这些类加载器的调用层次关系如下图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/JVM/parentsDelegationModel.png"></center>

<center>类加载器双亲委派模型</center>

<p>双亲委派模型的工作过程是：当一个类加载器收到类加载请求时，它会将请求传递给自己的父类加载器（它们之间并非继承关系，而是组合关系），请求委派会由其父类加载器去完成，当父类加载器不能够加载到指定类时，才由子类加载器尝试进行加载。</p>
<h2 id="3-垃圾回收与内存分配机制"><a href="#3-垃圾回收与内存分配机制" class="headerlink" title="3. 垃圾回收与内存分配机制"></a>3. 垃圾回收与内存分配机制</h2><p>上节主要介绍了类的声明周期，并介绍了类的加载过程。本节将介绍类的回收机制和内存分配机制。首先，本节将介绍Java虚拟机内存区域；接着介绍对象的创建访问；然后再介绍垃圾收集器的设计；最后介绍内存的分配与回收策略。</p>
<h3 id="3-1-Java虚拟机内存区域"><a href="#3-1-Java虚拟机内存区域" class="headerlink" title="3.1 Java虚拟机内存区域"></a>3.1 Java虚拟机内存区域</h3><p>虚拟机在java程序运行过程当中，将内存划分为5个区域进行管理，如下图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/JVM/javaArea.png" width="80%/"></center>

<center>Java虚拟机运行时内存区域</center>

<p>其中，Java虚拟机栈、本地方法栈和程序计数器这几个区域是线程私有的，方法区和堆是线程共享的。另外<strong>直接内存</strong>不是虚拟机运行时的内存区域，但在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作，这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。下面本节将主要介绍Java虚拟机中各个内存区域。</p>
<p><strong>程序计数器（Program Counter Register）</strong></p>
<p>该区域可以看作是当前线程所执行的字节码的行号指示器。它记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。</p>
<p><strong>Java虚拟机栈（VM Stack）</strong></p>
<p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。虚拟机栈的数据结构如图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/JVM/jvmStack.png" width="80%/"></center>

<center>Java虚拟机栈</center>

<p>该区域可能抛出以下异常：</p>
<ul>
<li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</li>
<li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</li>
</ul>
<p><strong>本地方法栈（Native Method Stack）</strong></p>
<p>本地方法栈与虚拟机栈类似，区别在于虚拟机栈为虚拟机执行java方法（字节码）服务，而本地方法栈则为虚拟机执行Native方法（一般是用C/C++等语言编写的，并编译为系统调用程序）服务。</p>
<p>由于虚拟机规范没有明确对本地方法栈中的语言和数据结构进行强制规定，从而使得一些虚拟机（Sun Hotspot）直接把本地方法栈与虚拟机栈合二为一。</p>
<p>该区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<p><strong>方法区</strong></p>
<p>方法区用于存储类的元数据信息，即Class文件中的数据项目，例如：类索引、字段、方法、属性等信息。</p>
<p>虚拟机规范规定当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
<p><strong>运行时常量池</strong>作为方法区的一部分，主要存放Class文件当中的常量池部分的运行时数据，运行时常量池相对于Class文件常量池的区别主要是：它不仅会保存Class文件中的符号引用，还会存储转换后的直接引用；同时具备动态性，即常量可以再运行期间载入到该区域。</p>
<p>当常量池无法再申请到内存时，虚拟机将会抛出OutOfMemoryError异常。</p>
<p><strong>堆区</strong></p>
<p>堆区主要是用于存储类的实例对象，也是垃圾手机的主要区域（GC堆）。</p>
<p>当堆内存无法再扩展时，虚拟机将会抛出OutOfMemoryError异常。</p>
<h3 id="3-2-对象的创建与访问"><a href="#3-2-对象的创建与访问" class="headerlink" title="3.2 对象的创建与访问"></a>3.2 对象的创建与访问</h3><p>上节介绍了虚拟机的运行时内存区域，上文也介绍了类的加载机制，那么一个类的对象实例时如何创建的呢？以及对象实例是如何访问的呢？本节将进行介绍。</p>
<p><strong>实例对象（不包括数组和Class对象）的创建</strong></p>
<p>虚拟机遇到new指令时，<strong>首先</strong>去检查常量池中是否能够定位到该类的符号引用，如果没有定位到，则进行类加载过程，如果定位到了，则为新生对象分配内存；<strong>内存分配完成后</strong>，虚拟机需要将分配的内存空间都初始化为零值（不包括对象头）；<strong>接下来</strong>，虚拟机需要设置对象头信息，例如：对象对应的类元数据信息的地址、对象的GC分代年龄等信息；<strong>在上面工作都完成之后</strong>，Java程序开始执行<code>&lt;init&gt;</code>方法，把对象按照开发人员的意愿进行初始化，这样一个对象也就创建完成了。</p>
<p>对象创建完成后，会形成3块数据区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。<strong>对象头</strong>主要存储两部分信息：第一部分用于存储对象运行时数据，例如：哈希码（HashCode）、分代年龄、锁状态标志等；第二部分用于存储类型指针，即对象指向它所对应的类元数据的指针。<strong>实例数据</strong>是对象真正存储的有效信息，即代码中定义的各种类型的字段内容（无论是从父类继承下来的，还是子类中定义的）。<strong>对齐填充</strong>仅仅起着占位符的作用，由于HotSpot要求对象的起始位置必须是8字节的整数倍，因此就需要通过对齐填充来补全。</p>
<p><strong>实例对象的访问</strong></p>
<p>对象的访问方式有两种：<strong>通过句柄访问和通过直接指针访问</strong>。如下图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/JVM/handlePoint.png" width="80%"></center>

<center>通过句柄访问对象</center>

<center><img src="http://zhoujianbo.gitee.io/notes/pics/JVM/directPoint.png" width="80%"></center>

<center>通过直接指针访问对象</center>

<p>其中HotSpot是通过直接指针进行对象访问的。</p>
<h3 id="3-3-垃圾收集器"><a href="#3-3-垃圾收集器" class="headerlink" title="3.3 垃圾收集器"></a>3.3 垃圾收集器</h3><p>上节介绍了实例对象的创建与访问，本节将主要介绍垃圾收集器的相关理论，主要包括<strong>如何判断对象已“死”？如何进行垃圾收集（垃圾收集算法）？如何发起垃圾回收过程？以及垃圾收集器的种类。</strong></p>
<p><strong>如何判断对象已“死”？</strong></p>
<p>第一种方法<strong>利用引用计数法</strong>，对每个对象添加一个引用计数器，当对象被引用时则计数器+1，引用失效时计数器-1，当进行对象回收时将引用计数器为0的对象进行回收。</p>
<p>这种方法存在问题，当两个对象相互引用时，会导致引用计数器永远不为0，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args0)</span></span>&#123;</span><br><span class="line">		Test a = <span class="keyword">new</span> Test(); <span class="comment">//对象a的引用计数器+1</span></span><br><span class="line">		Test b = <span class="keyword">new</span> Test(); <span class="comment">//对象b的引用计数器+1</span></span><br><span class="line">		a.instance = b; <span class="comment">//对象b的引用计数器+1</span></span><br><span class="line">		b.instance = a; <span class="comment">//对象a的引用计数器+1</span></span><br><span class="line">		a = <span class="keyword">null</span>; <span class="comment">//对象a的引用计数器-1</span></span><br><span class="line">		b = <span class="keyword">null</span>; <span class="comment">//对象b的引用计数器-1</span></span><br><span class="line">		doSomething();</span><br><span class="line">		<span class="comment">// 最后对象a和b的引用计数器都不为0，导致两个对象无法回收</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方法<strong>可达性分析算法</strong>，该算法的基本思路是构建一系列的“GC Roots”的对象作为起始点，当从这些起始点开始搜索，则可达的对象都是存活的，不可达的对象可被回收。如下图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/JVM/gcRoot.png" width="80%/"></center>

<center>可达性分析算法判定对象是否可回收</center>

<p>Java虚拟机主要是使用这种算法判断对象是否可回收。</p>
<p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。一个对象只有被引用和不被引用两种状态，对描述许多“食之无味，弃之可惜”的对象无能为力。因此在Java语言中提供了4种不同强度的引用里类型：</p>
<ol>
<li><p><strong>强引用</strong>，被强引用关联的对象不会被回收。使用 new 一个新对象的方式来创建强引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>软引用</strong>，被软引用关联的对象只有在内存不够的情况下才会被回收。使用 SoftReference 类来创建软引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>弱引用</strong>，被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。使用 WeakReference 类来创建弱引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> weakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>虚引用</strong>，又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。使用 PhantomReference 来创建虚引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj,<span class="keyword">null</span>);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>如何进行垃圾收集（垃圾收集算法）？</strong></p>
<p>垃圾收集算法主要包括三种：<strong>标记-清理算法、标记-整理算法以及复制算法</strong>。下面将分别介绍这几种算法的基本思路。</p>
<p><strong>标记-清理（Mark-Sweep）算法</strong>，首先标记可回收的对象（可达性塞法），然后清理可回收对象。过程如下图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/JVM/markSweep.png" width="70%"></center>

<center>标记-清理算法示意图</center>

<p>该算法的主要不足有两个：一是标记和清理过程效率不高；二是会产生大量内存碎片，导致大对象无法分配内存。</p>
<p><strong>标记-整理（Mark-Compact）算法</strong>，首先标记可回收的对象，然后将存活的对象向一端移动，最后将边界外的对象清理掉。过程如下图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/JVM/markCompact.png" width="70%"></center>

<center>标记-整理算法示意图</center>

<p>该算法的主要不足是需要移动大量对象，从而处理效率比较低。</p>
<p><strong>复制（Copying）算法</strong>，该算法是将内存划分为两块，每次只用其中的一块，当要进行垃圾回收时，则将存活的对象复制到另一块内存中。过程如图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/JVM/copying.png" width="70%"></center>

<center>复制算法示意图</center>

<p>该算法的不足是：当对象存活率较高时，虚拟机进行复制操作效率将会降低。</p>
<p>以上三种垃圾回收算法，各有各的优点和缺点。因此，商业虚拟机更具对象的存活周期，将内存划分为：<strong>新生代（Young Generation）和老年代（Tenured Generation）</strong>，这就是所谓的<strong>分代收集</strong>算法。新生代中的对象存活率较低，一般使用复制算法进行对象回收；老年代中的对象存活率高，一般使用“标记-清理”或者“标记-整理”算法进行对象回收。</p>
<p><strong>如何发起垃圾回收过程？</strong></p>
<p>在上述垃圾回收算法中都会涉及到对象标记过程，即用可达性分析算法从GC Roots节点寻找引用链的过程。个人理解，该过程主要有两个步骤：第一<strong>枚举根节点（GC Roots）</strong>，第二<strong>寻找引用链</strong>。但在这两个步骤中存在一些问题：第一，由于可以作为GC Roots的节点主要在全局性引用（例如常量或静态属性）和执行上下文（例如栈帧中的局部变量表）中，若要遍历这里面的引用来枚举根节点，需要花费大量时间；第二，在进行引用链寻找时，要求不可以在这个过程中对象的引用关系发生变化。对于第一个问题，HotSpot的实现是使用一组称为<strong>OopMap的数据结构</strong>来记录栈和寄存器中哪些位置是引用，这样就可以借助OopMap快速完成GC Roots枚举了；对于第二个问题，虚拟机在将要进行GC时，就把所有Java执行线程停顿（Sun 称这件事为<strong>“Stop The World”</strong>），这样对象的引用关系就不会在GC时发生变化了。</p>
<p>那么在什么情况下，可以进入Stop the world来进行GC过程？上文提到OopMap是记录下栈和寄存器中的引用所在位置，而该过程实在什么情况下记录的呢？当程序指令会导致对象引用关系发生变化时，虚拟机就会进行记录，我们称这些能够导致引用关系发生变化的指令位置为<strong>“安全点（safepiont）”</strong>。也就是说，GC过程需要在线程到达安全点时才进行。</p>
<p>对于多线程的情况，java线程并非同时到达安全点。因此，虚拟机有两种方式保证所用线程到达安全点后才进行GC过程。第一种是<strong>抢占式中断</strong>，即虚拟机强制发出中断指令，当java线程还没有到达安全点时，则让其继续运行直到到达安全点；第二种是<strong>主动式中断</strong>，即虚拟机在要进行中断时，只是设置一个中断标志，各个线程到达安全点后主动去轮询这个标志，当标志为真时则自己中断挂起。目前，抢占式中断方式已被弃用。</p>
<p>设置安全点+主动中断的方式已经解决了如何进入GC的问题，但实际会存在用户线程处于Sleep或者Block的状态，这时候用户线程就无法响应虚拟机的中断请求，从而使得GC过程无法进行。而解决此问题，虚拟机设计团队设置了<strong>“安全区域（Safe Region）”</strong>，它是指在一段代码中，引用关系没有发生变化的区域，即两个响铃安全点之间的指令区域。那么，当虚拟机要进行GC过程时，将无视标识处于安全区域的线程。</p>
<p><strong>垃圾收集器的种类</strong></p>
<p>上文介绍了HotSpot是<strong>如何发起内存回收过程的</strong>，但<strong>具体的回收过程如何进行？</strong>这与虚拟机采用的GC收集器有关，下面将介绍HotSpot中有哪些垃圾收集器。</p>
<p>垃圾收集工作主要集中在堆区，并且是基于<strong>分代收集</strong>方法，将堆区分为新生代和老年代，则对于不同的年代区域会有不同的垃圾收集器。下图显示了虚拟机包含的所有收集器以及连线表示收集器之间的可以进行搭配组合：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/JVM/gcs.jpg" width="80%/"></center>

<center>HotSpot虚拟机的垃圾收集器</center>

<p>下面将对这7种垃圾收集器做简单介绍。</p>
<p><strong>Serial收集器</strong>，是一个单线程的新生代收集器，使用复制算法。它只会利用一个CPU或一条收集线程去完成垃圾收集工作，并且在垃圾收集时会将所有用户线程暂停。</p>
<p><strong>ParNew收集器</strong>，是Serial收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为与Serial收集器完全一样。</p>
<p><strong>Parallel Scavenge收集器</strong>，是一个多线程的新生代收集器。它和ParNew的区别在于它的关注点与其他收集器不同。Serial、ParNew以及CMS等收集器关注的是垃圾收集时用户线程暂停的时间；而Parallel Scavenge关注的是达到一个可控制的吞吐量（Throughput）。其中吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。停顿时间越短越适合需要与用户交互的程序；而吞吐量越高可以越快的完成程序的运算任务，适合后台运算程序。个人理解，每次停顿时间越短，意味着整个程序需要多次停顿，则整体程序运行时间将增大，吞吐量将降低。</p>
<p><strong>Serial Old收集器</strong>，是Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理”算法。下图显示了Serial收集器与Serial收集器搭配使用的示意图：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/JVM/serialOld.jpg"></center>

<center>Serial/Serial Old收集器组合运行示意图</center>

<p><strong>Parallel Old收集器</strong>，是Parallel Scavenge收集器的老年代版本，使用“标记-整理”算法。下图显示了Parallel Scavenge收集器与Parallel Old收集器组合使用的示意图：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/JVM/parallelOld.jpg"></center>

<center>Parallel Scavenge/Parallel Old收集器组合运行示意图</center>

<p><strong>CMS（Concurrent Mark Sweep）收集器</strong>，是一个利用“标记-清除”算法的老年代收集器。它的工作过程较为复杂，可分为以下几个阶段：</p>
<ol>
<li>初始标记，仅仅是标记GC Roots能关联到的下一个对象；</li>
<li>并发标记，进行GC Roots Tracing过程（个人理解，即标记能关联到GC Roots的所有对象）；</li>
<li>重新标记，修正在并发标记过程种用户线程继续运行而导致的引用关系变更的那部分对象；</li>
<li>并发清理，清理掉可回收对象。</li>
</ol>
<p>其中，初始标记和重新标记还是Stop The World，并发标记和并发清理是与用户线程一起并发执行，而这两个过程是消耗时间最长的过程，所以CMS需要停顿的时间就很短。下图显示了CMS收集器运行的示意图：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/JVM/cms.jpg"></center>

<center>Concurrent Mark Sweep收集器运行示意图</center>

<p><strong>G1（Garbage-First）收集器</strong>，是在JDK1.7之后正式商用的收集器。</p>
<p>在G1收集器出现之前，其他收集器主要是基于分代进行垃圾收集工作，如下图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/JVM/HotspotHeapStructure.png"></center>

<center>一般收集器分代收集示意图</center>

<p>以往的垃圾收集器，如CMS，使用的堆内存结构如下：</p>
<ul>
<li>新生代：eden space + 2个survivor</li>
<li>老年代：old space</li>
<li>持久代：1.8之前的perm space</li>
<li>元空间：1.8之后的metaspace</li>
</ul>
<p>这些space必须是地址连续的空间。</p>
<p>在G1算法中，采用了另外一种完全不同的方式组织堆内存，堆内存被划分为多个大小相等的内存块（Region），每个Region是逻辑连续的一段内存，结构如下：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/JVM/G1HeapAllocation.png"></center>

<p>每个Region被标记了E、S、O和H，说明每个Region在运行时都充当了一种角色，其中H是以往算法中没有的，它代表Humongous，这表示这些Region存储的是巨型对象（humongous object，H-obj），当新建对象大小超过Region大小一半时，直接在新的一个或多个连续Region中分配，并标记为H。为避免可达性分析时进行全堆扫描，每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。</p>
<p>G1收集器的运作大致可划分为以下几个步骤：</p>
<ol>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ol>
<p>G1收集器的工作过程如下图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/JVM/g1.jpg"></center>

<center>G1垃圾收集器运行示意图</center>

<h3 id="3-4-内存分配与回收策略"><a href="#3-4-内存分配与回收策略" class="headerlink" title="3.4 内存分配与回收策略"></a>3.4 内存分配与回收策略</h3><p>上节介绍了垃圾收集的相关知识，本节将介绍对象的内存分配策略。对象的内存分配，从大方向上讲，对象主要是分配在堆区的新生代的Eden区上；如果启动了本地线程缓冲，将按线程优先在TLAB上分配；在少数情况下会分配在老年代中。而这是基本的分配规则，而内存分配细节取决于垃圾收集器的组合，以及虚拟机中与内存相关的参数设置。</p>
<p>下文将介绍最普遍的内存分配规则，<strong>在使用Serial/Serial Old收集器组合的情况下的内存分配与回收策略（ParNew/PaSerial Old收集器组合下的策略基本一致）</strong>。在这种组合下，依然存在新生代和老年代的概念，一般称新生代GC为<strong>Minor GC</strong>，老年代GC为<strong>Major GC或者Full GC</strong>。下文将介绍最普遍的内存分配规则。</p>
<p><strong>1）对象优先分配在Eden区</strong></p>
<p>大多数情况下，虚拟机会在新生代 Eden 上为对象分配内存，当 Eden 空间不够时，发起 Minor GC。</p>
<p><strong>2）大对象直接进入老年代</strong></p>
<p>当大对象（例如很长的字符串或数组）需要分配内存时，虚拟机判断是否申请的空间是否大于PretenureSizeThreshold参数，大于该参数则直接分配到老年代。</p>
<p><strong>3）长期存活的对象进入老年代</strong></p>
<p>当一些对象经历过几次Minor GC依然存活时，虚拟机判断对象的年龄是否大于MaxtenuringThreshold参数，大于该参数则将对象移到老年代中。</p>
<p><strong>4）动态对象年龄判定</strong></p>
<p>虚拟机并不是永远要求对象在达到年龄后才转入老年代，如果Survivor空间中的年龄相同的对象所占的内存总和大于Survivor空间的一半，那么大于或等于该年龄的对象将直接进入老年代。</p>
<p><strong>5）空间分配担保</strong></p>
<p>之前都是在Minor GC时，判定对象是否可以进入老年代的规则。而在进行Minor GC之前，虚拟机首先需要判断老年代的最大可用连续空间是否大于新生代所有存活对象的总空间。如果条件成立，则Minor GC 可以确定是安全的，可以执行Minor GC。</p>
<p>如果不成立，虚拟机接着会查看HandlePromotionFailure设置值是否允许担保失败。如果不允许，将进行一次Full GC操作。</p>
<p>如果允许，虚拟机将会继续判断老年代的最大可用连续空间是否大于历次晋升到老年代中对象的平均大小。如果小于，则担保失败，进行一次Full GC操作。如果大于，则尝试进行一次Minor GC。当然也有可能在执行Minor GC操作时，发现晋升到老年代对象的空间大于老年代的最大可用连续空间，则进行一次Full GC操作。</p>
<p>整个空间分配担保流程如下图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/JVM/handlePromotion.png"></center>

<center>空间分配担保流程图</center>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="<https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA">Java虚拟机-cyc2018</a></p>
<p>深入理解Java虚拟机</p>
=======
        <h1 id="介绍（可微神经网络）"><a href="#介绍（可微神经网络）" class="headerlink" title="介绍（可微神经网络）"></a>介绍（可微神经网络）</h1><p>如今，人工神经网络已经在模式识别、序列学习和强化学习方面表现出色，但因为没有额外的存储机制，使得在表示变量和需要存储长时间数据的情况下，神经网络的能力被有所限制。本文将基于Deepmind于2016年发表在《自然》杂志上的文章，对文章中所提出的可微神经计算机(Differentiable neural computer)进行一定的介绍，并针对Deepmind开源在Github上的代码进行一定的分析。</p>
<p>可微神经计算机（之后简称DNC）的一个单元(cell)主要由一个控制器和一个存储器构成，如图所示：<br><img src="./images/DNC_architecture.png" alt="Figure 1: DNC architecture."></p>
>>>>>>> origin/master

      
    </div>
    <footer class="article-footer">
<<<<<<< HEAD
      <a data-url="http://yoursite.com/2019/09/15/JVM笔记（理论篇）/" data-id="ck0kz0nof0003kst01afmpusc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Git入门笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/15/Git入门笔记/" class="article-date">
  <time datetime="2019-09-15T12:43:26.880Z" itemprop="datePublished">2019-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/15/Git入门笔记/">Git 入门笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Git-入门笔记"><a href="#Git-入门笔记" class="headerlink" title="Git 入门笔记"></a>Git 入门笔记</h1><p>[TOC]</p>
<p>本文主要参考<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Git官方教程</a>及<a href="https://www.yiibai.com/git/" target="_blank" rel="noopener">git易百教程</a>，整理介绍Git版本管理工具的一些基本概念以及基本操作。</p>
<h2 id="1-Git是什么？"><a href="#1-Git是什么？" class="headerlink" title="1. Git是什么？"></a>1. Git是什么？</h2><p>Git是一种<strong>版本控制工具</strong>，版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。版本控制系统具有三种类型，分别是：本地版本控制系统、集中化的版本控制系统和分布式版本控制系统。三种类型系统的形态如下图所示:</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/vcs1.png" width="50%"></center>

<center>本地版本控制系统</center>

<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/vcs2.png" width="50%"></center>

<center>集中式版本控制系统</center>

<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/vcs3.png" width="50%"></center>

<center>分布式版本控制系统</center>

<p>其中，Git就是分布式版本控制系统，对于这三种系统的优缺点这里不做介绍。</p>
<p>个人理解，Git的入门可以划分为三个层次：第一是单分支操作，第二是多分支操作，第三是加入远程分支之后的操作。下文将分别介绍这三种情况下的一些基本概念与操作。</p>
<h2 id="2-Git单分支操作"><a href="#2-Git单分支操作" class="headerlink" title="2. Git单分支操作"></a>2. Git单分支操作</h2><p>在开始使用Git工具时，我们可能并未考虑到分支操作，以及远程仓库的使用。本节将主要介绍Git工具的基本概念以及单分支本地操作，包括Git如何保存数据，Git项目管理的三个工作区域，如何获取Git仓库，如何跟新每次提交到仓库，如何查看提交历史，如何撤销Git操作。</p>
<h3 id="2-1-直接记录快照，而非差异比较"><a href="#2-1-直接记录快照，而非差异比较" class="headerlink" title="2.1 直接记录快照，而非差异比较"></a>2.1 直接记录快照，而非差异比较</h3><p>首先，Git在记录每个版本时，它记录的是什么？有些版本控制系统记录的是基本文件和每个文件随时间逐步积累的差异。如下图所示:</p>
<p>首先，Git在记录每个版本时，他记录的是什么？有些版本控制系统记录的是基本文件和每个文件随时间逐步积累的差异，如下图所示。</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/deltas.png" width="80%"></center>

<center>存储每个文件与初始版本的差异</center>

<p>而Git和其他版本控制系统存在一些区别，它主要记录的是文件<strong>快照</strong>。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong>。存储项目随时间改变的快照如下图所示:</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/snapshots.png" width="80%"></center>

<center>存储项目随时间改变的快照</center>

<p>那么，文件快照是什么？下文会做介绍。</p>
<h3 id="2-2-三个区域"><a href="#2-2-三个区域" class="headerlink" title="2.2 三个区域"></a>2.2 三个区域</h3><p>为之后更好理解Git，这里介绍Git项目的三个工作区域：Git仓库、暂存区域以及工作目录。三个工作区域的关系如下图所示:</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/workAreas.png" width="80%"></center>

<center>工作目录、暂存区域以及 Git 仓库</center>

<p>工作目录工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p>
<p>暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。</p>
<p>Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</p>
<h3 id="2-3-获取Git仓库"><a href="#2-3-获取Git仓库" class="headerlink" title="2.3 获取Git仓库"></a>2.3 获取Git仓库</h3><p>在本地创建一个Git管理的项目，首先需要获取Git仓库，有两种取得 Git 项目仓库的方法： 第一种是在现有项目或目录下导入所有文件到 Git 中； 第二种是从一个服务器克隆一个现有的 Git 仓库。</p>
<p><strong>第一种方式</strong>，你只需要进入项目目录并输入：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>该命令将创建一个名为 <code>.git</code> 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。</p>
<p><strong>第二种方式</strong>，你将获得一份已经存在了的 Git 仓库的拷贝。克隆仓库的命令格式是 <code>git clone [url]</code> 。 比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/libgit2/libgit2</span><br></pre></td></tr></table></figure>

<p>这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹，从远程仓库拉取下所有数据放入 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝。</p>
<p> 如果你进入到这个新建的 <code>libgit2</code> 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。 如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/libgit2/libgit2 mylibgit</span><br></pre></td></tr></table></figure>

<p>这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为 <code>mylibgit</code>。</p>
<h3 id="2-4-记录每次更新到仓库"><a href="#2-4-记录每次更新到仓库" class="headerlink" title="2.4 记录每次更新到仓库"></a>2.4 记录每次更新到仓库</h3><p>现在我们手上有了一个真实项目的 Git 仓库，接下来，对项目文件做些修改，在完成了一个阶段的目标之后，提交本次更新到仓库。本节将介绍在此过程中文件状态的转换和需要的操作。</p>
<p><strong>文件状态</strong></p>
<p>文件状态都不外乎两种状态：<strong>已追踪</strong>和<strong>未追踪</strong>。<strong>已跟踪的文件</strong>是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。工作目录中除已跟踪文件以外的所有其它文件都属于<strong>未跟踪文件</strong>，它们既不存在于上次快照的记录中，也没有放入暂存区。同时，已追踪状态又可分为：<strong>未修改(Unmodified)/已提交(Committed)、已修改(Modified)和已暂存(Staged)</strong>。</p>
<p>当我们在项目中新建一个文件时，该文件处于未追踪(Untracked)状态；我们输入添加命令，文件进入暂存状态；我们输入提交命令后，文件进入已提交状态或者叫未修改状态；自上次提交后我们对文件做了修改，文件进入已修改状态；我们在此输入添加命令，文件再次进入已暂存状态。如此反复，Git项目下的文件生命周期如下图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/lifecycle.png" width="80%"></center>

<center>文件的状态变化周期</center>

<p><strong>查看当前文件状态</strong></p>
<p>我们要<strong>查看哪些文件处于什么状态</strong>，可以用 <code>git status</code> 命令。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>

<p><strong>追踪新文件</strong></p>
<p>我们要<strong>追踪一个文件</strong>，可以使用命令 <code>git add [file]</code> 。 例如，我们要跟踪 README 文件，可以运行<code>git add README</code>命令。</p>
<p><strong>暂存已修改文件</strong></p>
<p>当我们修改了一个已被跟踪并处于暂存状态的文件，则该文件将变为已修改状态，我们需要重新运行命令 <code>git add [file]</code> 使其进入暂存状态。例如，如果我们修改了一个名为 <code>CONTRIBUTING.md</code> 的已被跟踪的文件，我们可以运行 <code>git add CONTRIBUTING.md</code> 将”CONTRIBUTING.md”重新放到暂存区。</p>
<p><strong>提交更新到仓库</strong></p>
<p>我们要<strong>提交更新到仓库</strong>，可以使用命令<code>git commit</code>。<strong>Git只会提交处于暂存状态的文件给仓库</strong>。因此，在此之前，请一定要确认还有什么修改过的或新建的文件还没有 <code>git add</code> 过，否则提交的时候不会记录这些还没暂存起来的变化。 这些修改过的文件只保留在本地磁盘。 所以，每次准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>。</p>
<p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个<strong>跳过使用暂存区域</strong>的方式， 只要在提交的时候，给 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤。</p>
<p><strong>忽略文件</strong></p>
<p>有时我们需要<strong>忽略一些文件</strong>，这些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件模式。文件 <code>.gitignore</code> 的格式规范如下：</p>
<ul>
<li>所有空行或者以 <code>＃</code> 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配。</li>
<li>匹配模式可以以（<code>/</code>）开头防止递归。</li>
<li>匹配模式可以以（<code>/</code>）结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反。</li>
</ul>
<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code>匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。 使用两个星号（<code>*</code>) 表示匹配任意中间目录，比如 <code>a/**/z</code> 可以匹配 <code>a/z</code> , <code>a/b/z</code> 或 <code>a/b/c/z</code> 等。我们看一个 <code>.gitignore</code> 文件的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># no .a files</span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"># but do track lib.a, even though you&apos;re ignoring .a files above</span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"># only ignore the TODO file in the current directory, not subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"># ignore all files in the build/ directory</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"># ignore doc/notes.txt, but not doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"># ignore all .pdf files in the doc/ directory</span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure>

<p><strong>查看已暂存和未暂存的修改</strong></p>
<p>有时，我们需要查看尚未暂存的文件更新了哪些部分，可以不加参数直接输入 <code>git diff</code>。此命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。</p>
<p>若要查看已暂存的将要添加到下次提交里的内容，可以用 <code>git diff --cached</code> 命令。（Git 1.6.1 及更高版本还允许使用 <code>git diff --staged</code>，效果是相同的，但更好记些。）</p>
<p><strong>移除文件</strong></p>
<p>有时，我们需要从 Git 中移除已被追踪某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 <code>git rm [file]</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p>
<p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <code>-f</code>（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。</p>
<p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。比如，当你忘记添加 <code>.gitignore</code> 文件，不小心把一个很大的日志文件或一堆 <code>.a</code> 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 <code>--cached</code> 选项。例如，我们向让已被暂存的README文件从Git控制中删除，但需要其保留在磁盘中，我们可以输入命令<code>git rm --cached README</code>完成操作。</p>
<p>另外，<code>git rm</code> 命令后面可以列出文件或者目录的名字，也可以使用 <code>glob</code> 模式。例如：<code>git rm log/\*.log</code>，注意到星号 <code>*</code> 之前的反斜杠 <code>\</code>， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。 此命令删除 <code>log/</code> 目录下扩展名为 <code>.log</code> 的所有文件。</p>
<p><strong>移动文件</strong></p>
<p>有时，我们会移动或重命名文件，可以运行<code>git mv &lt;options&gt; ... &lt;args&gt; ...</code>完成操作。该命令存在两种形式的调用，第一种形式是重命名操作，调用方式为<code>git mv &lt;source&gt; &lt;destination&gt;</code>；第二种方式是移动文件操作，盗用方式为<code>git mv &lt;source&gt; ... &lt;destination directory&gt;</code>。</p>
<p>例如，把 文件<em>text.txt</em> 移动到 <em>mydir</em>目录下，可以执行以下操作 - </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mv text.txt mydir</span><br></pre></td></tr></table></figure>

<p>运行上面的 <code>git mv</code> 其实就相当于运行了<code>3</code>条命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv test.txt mydir/</span><br><span class="line">$ git rm test.txt</span><br><span class="line">$ git add mydr</span><br></pre></td></tr></table></figure>

<h3 id="2-5-查看提交历史"><a href="#2-5-查看提交历史" class="headerlink" title="2.5 查看提交历史"></a>2.5 查看提交历史</h3><p>有时，我们需要查看一下Git项目中文件的提交历史情况，本节将介绍命令<code>git log</code>，并列举一些该命令的常用选项。</p>
<p><strong>查看提交的基本历史信息</strong></p>
<p>运行 git log，应该会看到下面的输出：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure>

<p>默认不用任何参数的话，<code>git log</code> 会按提交时间列出所有的更新，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p>
<p><strong>查看每次提交的内容差异</strong></p>
<p>如果，我们想查看每次提交的内容差异，可以利用选项<code>-p</code>，并加上 <code>-2</code> 来仅显示最近两次提交：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p -2</span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br><span class="line"></span><br><span class="line">diff --git a/Rakefile b/Rakefile</span><br><span class="line">index a874b73..8f94139 100644</span><br><span class="line">--- a/Rakefile</span><br><span class="line">+++ b/Rakefile</span><br><span class="line">@@ -5,7 +5,7 @@ require 'rake/gempackagetask'</span><br><span class="line"> spec = Gem::Specification.new do |s|</span><br><span class="line">     s.platform  =   Gem::Platform::RUBY</span><br><span class="line">     s.name      =   "simplegit"</span><br><span class="line">-    s.version   =   "0.1.0"</span><br><span class="line">+    s.version   =   "0.1.1"</span><br><span class="line">     s.author    =   "Scott Chacon"</span><br><span class="line">     s.email     =   "schacon@gee-mail.com"</span><br><span class="line">     s.summary   =   "A simple gem for using Git in Ruby code."</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test</span><br><span class="line"></span><br><span class="line">diff --git a/lib/simplegit.rb b/lib/simplegit.rb</span><br><span class="line">index a0a60ae..47c6340 100644</span><br><span class="line">--- a/lib/simplegit.rb</span><br><span class="line">+++ b/lib/simplegit.rb</span><br><span class="line">@@ -18,8 +18,3 @@ class SimpleGit</span><br><span class="line">     end</span><br><span class="line"></span><br><span class="line"> end</span><br><span class="line">-</span><br><span class="line">-if $0 == __FILE__</span><br><span class="line">-  git = SimpleGit.new</span><br><span class="line">-  puts git.show</span><br><span class="line">-end</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure>

<p>该选项除了显示基本信息之外，还附带了每次 commit 的变化。 当进行代码审查，或者快速浏览某个搭档提交的 commit 所带来的变化的时候，这个参数就非常有用了。 </p>
<p><strong>查看格式化的提交历史</strong></p>
<p>另外一个常用的选项是 <code>--pretty</code>。 这个选项可以指定使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如用 <code>oneline</code> 将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有 <code>short</code>，<code>full</code> 和 <code>fuller</code> 可以用，展示的信息或多或少有些不同，请自己动手实践一下看看效果如何。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">ca82a6dff817ec66f44342007202690a93763949 changed the version number</span><br><span class="line">085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test</span><br><span class="line">a11bef06a3f659402fe7563abf99ad00de2209e6 first commit</span><br></pre></td></tr></table></figure>

<p>但最有意思的是 format，可以定制要显示的记录格式。 这样的输出对后期提取分析格外有用 — 因为你知道输出的格式不会随着 Git 的更新而发生改变：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=format:<span class="string">"%h - %an, %ar : %s"</span></span></span><br><span class="line">ca82a6d - Scott Chacon, 6 years ago : changed the version number</span><br><span class="line">085bb3b - Scott Chacon, 6 years ago : removed unnecessary test</span><br><span class="line">a11bef0 - Scott Chacon, 6 years ago : first commit</span><br></pre></td></tr></table></figure>

<p><a href="https://git-scm.com/book/zh/v2/ch00/rpretty_format" target="_blank" rel="noopener"><code>git log --pretty=format</code> 常用的选项</a> 列出了常用的格式占位符写法及其代表的意义。</p>
<p>当 oneline 或 format 与另一个 <code>log</code> 选项 <code>--graph</code> 结合使用时尤其有用。 这个选项添加了一些ASCII字符串来形象地展示你的分支、合并历史：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=format:<span class="string">"%h %s"</span> --graph</span></span><br><span class="line">* 2d3acf9 ignore errors from SIGCHLD on trap</span><br><span class="line">*  5e3ee11 Merge branch 'master' of git://github.com/dustin/grit</span><br><span class="line">|\</span><br><span class="line">| * 420eac9 Added a method for getting the current branch.</span><br><span class="line">* | 30e367c timeout code and tests</span><br><span class="line">* | 5a09431 add timeout protection to grit</span><br><span class="line">* | e1193f8 support for heads with slashes in them</span><br><span class="line">|/</span><br><span class="line">* d6016bc require time for xmlschema</span><br><span class="line">*  11d191e Merge branch 'defunkt' into local</span><br></pre></td></tr></table></figure>

<p>这种输出类型会在学完分支与合并以后变得更加有趣。</p>
<h3 id="2-6-撤销操作"><a href="#2-6-撤销操作" class="headerlink" title="2.6 撤销操作"></a>2.6 撤销操作</h3><p>有时，我们存在操作错误，需要撤销操作，本节将简单介绍如何取消提交操作，如何取消暂存文件，如何撤销已修改的文件，以及如何取消远程仓库的push，</p>
<p><strong>提交（commit）操作的撤销</strong></p>
<p>有时，我们commit之后，想撤销commit操作，分为以下几种情况：提交后发现注释写错了或有几个文件没有提交，提交后发现许多文件不应该提交。</p>
<p>第一种情况，我们可以先运行<code>git add [file-name]</code>将文件加入暂存区域，利用<code>git commit -amend</code>，进入注释编辑界面，输入注释，完成提交，这样的操作会覆盖之前最后一次提交操作。</p>
<p>第二种情况，我们可以运行<code>git reset --soft HEAD~1</code>撤销最后一次提交操作，但不撤销<code>git add</code>操作；也可以运行<code>git reset --mixed HEAD~1</code>撤销最后一次提交操作，并且撤销<code>git add</code>操作；注意命令<code>git reset --hard HEAD~1</code>完成这个操作后，就恢复到了上一次的commit状态。</p>
<p><strong>取消暂存</strong></p>
<p>有时，你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 <code>git add *</code> 暂存了它们两个。 如何只取消暂存两个中的一个呢？比如我么需要取消暂存 <code>CONTRIBUTING.md</code> 文件，我们可以运行以下命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset HEAD CONTRIBUTING.md</span></span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M	CONTRIBUTING.md</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use "git reset HEAD &lt;file&gt;..." to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add &lt;file&gt;..." to update what will be committed)</span><br><span class="line">  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>

<p>这样 <code>CONTRIBUTING.md</code> 文件已经是修改未暂存的状态了。</p>
<p><strong>撤销已修改的文件</strong></p>
<p>如果你并不想保留对 <code>CONTRIBUTING.md</code> 文件的修改怎么办？ 你该如何方便地撤消修改 ？我们可以执行：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add &lt;file&gt;..." to update what will be committed)</span><br><span class="line">  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- CONTRIBUTING.md</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use "git reset HEAD &lt;file&gt;..." to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br></pre></td></tr></table></figure>

<p>可以看到那些修改已经被撤消了。</p>
<p><strong>取消远程仓库的push</strong></p>
<p>有时，我们把错误的本地提交推送到了远程仓库中，当我们在本地撤销提交后，如何将落后于远程追踪分支的本地分支推送至远程仓库呢？一种可行的做法是运行命令<code>git push -f [remote-name]</code>，将当前本地分支强制推送到远程分支。</p>
<h2 id="3-Git多分支操作"><a href="#3-Git多分支操作" class="headerlink" title="3. Git多分支操作"></a>3. Git多分支操作</h2><p>上节介绍了Git在单分支场景下文件的状态和操作，本节将介绍Git在多分支场景下的操作，包括：Git是如何保存数据的，如何创建分支，如何切换分支，如何合并与删除分支，以及一些分支信息查看的分支管理命令。</p>
<h3 id="3-1-Git是如何保存数据的？"><a href="#3-1-Git是如何保存数据的？" class="headerlink" title="3.1 Git是如何保存数据的？"></a>3.1 Git是如何保存数据的？</h3><p>为了真正理解 Git 处理分支的方式，我们需要回顾一下 Git 是如何保存数据的。本文开头介绍了Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。那它是如何保存这些数据的呢？</p>
<p>在进行提交操作时，Git 会保存一个<strong>提交对象（commit object）</strong>。该对象包含包含<strong>一个指向暂存内容快照的指针</strong>、<strong>作者的姓名和邮箱</strong>、<strong>提交时输入的信息</strong>以及<strong>指向它的父对象的指针</strong>。其中，首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象。</p>
<p>为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。<strong>暂存操作</strong>会为每一个文件计算校验和（使用 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交。当进行<strong>提交操作</strong>时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git 仓库中这些校验和保存为树对象。 随后，Git 便会创建一个提交对象。这样，Git 仓库中有五个对象：<strong>三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）</strong>。首次提交对象及其树结构如图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/commit-and-tree.png">

<center>首次提交对象及其树结构</center>

<p>做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。如图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/commits-and-parents.png"></center>


<center>提交对象及其父对象</center>

<p>Git 的分支，其实本质上仅仅是<strong>指向提交对象的可变指针</strong>。</p>
<h3 id="3-2-分支创建"><a href="#3-2-分支创建" class="headerlink" title="3.2 分支创建"></a>3.2 分支创建</h3><p>Git 的默认分支名字是 <code>master</code>。 Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 <code>git branch</code> 命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch testing</span></span><br></pre></td></tr></table></figure>

<p>这会在当前所在的提交对象上创建一个指针。</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/two-branches.png" width="80%"></center>

<center>两个指向相同提交历史的分支</center>

<p>那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 <code>HEAD</code> 的特殊指针。在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 <code>HEAD</code> 想象为当前分支的别名）。 在本例中，你仍然在 <code>master</code> 分支上。 因为 <code>git branch</code> 命令仅仅 <em>创建</em> 一个新分支，并不会自动切换到新分支中去。</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/head-to-master.png" width="80%"></center>

<center>HEAD 指向当前所在的分支</center>

<h3 id="3-3-分支切换"><a href="#3-3-分支切换" class="headerlink" title="3.3 分支切换"></a>3.3 分支切换</h3><p><strong>切换分支到testing</strong></p>
<p>有时，我们需要切换到一个已存在的分支，可以使用 <code>git checkout</code> 命令。 我们现在切换到新创建的 <code>testing</code> 分支去：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout testing</span></span><br></pre></td></tr></table></figure>

<p>这样 <code>HEAD</code> 就指向 <code>testing</code> 分支了，如图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/head-to-testing.png" width="80%"></center>

<center>HEAD 指向当前所在的分支</center>

<p><strong>再次提交testing分支</strong></p>
<p>那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim test.rb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m <span class="string">'made a change'</span></span></span><br></pre></td></tr></table></figure>

<p>如图所示，<code>testing</code> 分支向前移动了，但是 <code>master</code> 分支却没有，它仍然指向运行 <code>git checkout</code> 时所指的对象。</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/advance-testing.png" width="80%"></center>

<center>HEAD 分支随着提交操作自动向前移动</center>

<p><strong>切换回master分支</strong></p>
<p>现在我们切换回 <code>master</code> 分支看看：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br></pre></td></tr></table></figure>

<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/checkout-master.png" width="80%"></center>

<center>检出时 HEAD 随之移动</center>

<p>这条命令做了两件事。 一是使 HEAD 指回 <code>master</code> 分支，二是将工作目录恢复成 <code>master</code> 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 <code>testing</code>分支所做的修改，以便于向另一个方向进行开发。</p>
<p><strong>master分支修改后再次提交</strong></p>
<p>我们不妨再稍微做些修改并提交：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim test.rb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m <span class="string">'made other changes'</span></span></span><br></pre></td></tr></table></figure>

<p>现在，这个项目的提交历史已经产生了分叉（参见 <a href="https://git-scm.com/book/zh/v2/ch00/rdivergent_history" target="_blank" rel="noopener">项目分叉历史</a>）。</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/advance-master.png" width="80%"></center>

<center>项目分叉历史</center>

<p>因为刚才我们创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 <code>branch</code>、<code>checkout</code> 和 <code>commit</code>。</p>
<p>由于 Git 的分支实质上仅是<strong>包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件</strong>，创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），所以它的创建和销毁都异常高效。</p>
<h3 id="3-4-分支合并删除"><a href="#3-4-分支合并删除" class="headerlink" title="3.4 分支合并删除"></a>3.4 分支合并删除</h3><p>本节将一个例子讲解分支的合并。</p>
<p><strong>新建iss53分支，并进行一次提交</strong></p>
<p>现在，假如你需要要解决项目中的 #53 问题。 你可以在<code>master</code>分支的基础上新建一个<code>iss53</code>分支并同时切换到这个分支上，运行一个带有 <code>-b</code> 参数的 <code>git checkout</code> 命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b iss53</span></span><br><span class="line">Switched to a new branch "iss53"</span><br></pre></td></tr></table></figure>

<p>它是下面两条命令的简写：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch iss53</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout iss53</span></span><br></pre></td></tr></table></figure>

<p>你继续在 #53 问题上工作，并且做了一些提交。 在此过程中，<code>iss53</code> 分支在不断的向前推进，因为你已经检出到该分支（也就是说，你的 <code>HEAD</code> 指针指向了 <code>iss53</code> 分支）</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim index.html</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m <span class="string">'added a new footer [issue 53]'</span></span></span><br></pre></td></tr></table></figure>

<p><strong>新建hotfix分支，并进行一次提交</strong></p>
<p>现在你接到那个电话，有个紧急问题等待你来解决。你可以在<code>master</code>分支的基础上新建一个<code>hotfix</code>分支并同时切换到这个分支上，在该分支上工作直到问题解决：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b hotfix</span></span><br><span class="line">Switched to a new branch 'hotfix'</span><br><span class="line"><span class="meta">$</span><span class="bash"> vim index.html</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m <span class="string">'fixed the broken email address'</span></span></span><br><span class="line">[hotfix 1fb7853] fixed the broken email address</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure>

<p><strong>master分支与hotfix分支合并（快进合并）</strong></p>
<p>当紧急问题解决后，你需要合并回 <code>master</code> 分支。 你可以使用 <code>git merge</code> 命令来达到上述目的：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge hotfix</span></span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast-forward</span><br><span class="line"> index.html | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure>

<p>在合并的时候，你应该注意到了”快进（fast-forward）”这个词。 由于当前 <code>master</code> 分支所指向的提交是你当前提交（有关 hotfix 的提交）的直接上游，所以 Git 只是简单的将指针向前移动。</p>
<p>现在，最新的修改已经在 <code>master</code> 分支所指向的提交快照中，你可以着手发布该修复了。如图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/basic-branching-5.png" width="80%"></center>

<center> `master` 被快进到 `hotfix` </center>

<p><strong><code>hotfix</code>分支删除</strong></p>
<p>关于这个紧急问题的解决方案发布之后，你应该先删除 <code>hotfix</code>分支，因为你已经不再需要它了 —— <code>master</code> 分支已经指向了同一个位置。 你可以使用带 <code>-d</code> 选项的 <code>git branch</code> 命令来删除分支：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d hotfix</span></span><br><span class="line">Deleted branch hotfix (3a0874c)</span><br></pre></td></tr></table></figure>

<p><strong><code>iss53</code>分支完成后，合并到<code>master</code>分支中（无冲突合并）</strong></p>
<p>现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53 问题的那个分支（iss53 分支）。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout iss53</span></span><br><span class="line">Switched to branch "iss53"</span><br><span class="line"><span class="meta">$</span><span class="bash"> vim index.html</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m <span class="string">'finished the new footer [issue 53]'</span></span></span><br><span class="line">[iss53 ad82d7a] finished the new footer [issue 53]</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>假设你已经修正了 #53 问题，并且打算将你的工作合并入 <code>master</code> 分支。 为此，你需要合并 <code>iss53</code> 分支到 <code>master</code> 分支，这和之前你合并 <code>hotfix</code> 分支所做的工作差不多。 你只需要检出到你想合并入的分支，然后运行 <code>git merge</code> 命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line">Switched to branch 'master'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge iss53</span></span><br><span class="line">Merge made by the 'recursive' strategy.</span><br><span class="line">index.html |    1 +</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>这和之前合并 <code>hotfix</code> 分支的时候看起来有一点不一样。 在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，<code>master</code> 分支所在提交并不是 <code>iss53</code> 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（<code>C4</code> 和 <code>C5</code>）以及这两个分支的工作祖先（<code>C2</code>），做一个简单的三方合，如图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/basic-merging-1.png"></center>

<center>一次典型合并中所用到的三个快照</center>

<p>和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交，如图所示：</p>
<center><img src="http://zhoujianbo.gitee.io/notes/pics/Git/basic-merging-2.png"></center>

<center>一个合并提交</center>

<p>需要指出的是，Git 会自行决定选取哪一个提交作为最优的共同祖先，并以此作为合并的基础。Git 的这个优势使其在合并操作上比其他系统要简单很多。</p>
<p><strong><code>iss53</code>分支合并到<code>master</code>分支中（有冲突合并）</strong></p>
<p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 如果你对 #53 问题的修改和有关 <code>hotfix</code> 的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge iss53</span></span><br><span class="line">Auto-merging index.html</span><br><span class="line">CONFLICT (content): Merge conflict in index.html</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 <code>git status</code> 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run "git commit")</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use "git add &lt;file&gt;..." to mark resolution)</span><br><span class="line"></span><br><span class="line">    both modified:      index.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure>

<p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line">=======</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line"> please contact us at support@github.com</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure>

<p>这表示 <code>HEAD</code> 所指示的版本（也就是你的 <code>master</code> 分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支）在这个区段的上半部分（<code>=======</code> 的上半部分），而 <code>iss53</code> 分支所指示的版本在 <code>=======</code> 的下半部分。 为了解决冲突，你必须选择使用由 <code>=======</code> 分割的两部分中的一个，或者你也可以自行合并这些内容。 例如，你可以通过把这段内容换成下面的样子来解决冲突：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line">please contact us at email.support@github.com</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>上述的冲突解决方案仅保留了其中一个分支的修改，并且 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> , <code>=======</code> , 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 这些行被完全删除了。 在你解决了所有文件里的冲突之后，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。</p>
<p>如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 <code>git commit</code> 来完成合并提交。 默认情况下提交信息看起来像下面这个样子：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Merge branch 'iss53'</span><br><span class="line"></span><br><span class="line">Conflicts:</span><br><span class="line">    index.html</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> It looks like you may be committing a merge.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> If this is not correct, please remove the file</span></span><br><span class="line"><span class="meta">#</span><span class="bash">	.git/MERGE_HEAD</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> and try again.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Please enter the commit message <span class="keyword">for</span> your changes. Lines starting</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> with <span class="string">'#'</span> will be ignored, and an empty message aborts the commit.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> All conflicts fixed but you are still merging.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">	modified:   index.html</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br></pre></td></tr></table></figure>

<p>如果你觉得上述的信息不够充分，不能完全体现分支合并的过程，你可以修改上述信息，添加一些细节给未来检视这个合并的读者一些帮助，告诉他们你是如何解决合并冲突的，以及理由是什么。</p>
<h3 id="3-5-分支管理"><a href="#3-5-分支管理" class="headerlink" title="3.5 分支管理"></a>3.5 分支管理</h3><p>现在已经创建、合并、删除了一些分支，让我们看看一些常用的分支管理工具。</p>
<p><strong>查看所有分支</strong></p>
<p><code>git branch</code> 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">  iss53</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure>

<p>注意 <code>master</code> 分支前的 <code>*</code> 字符：它代表现在检出的那一个分支（也就是说，当前 <code>HEAD</code> 指针所指向的分支）。</p>
<p>如果需要查看每一个分支的最后一次提交，可以运行 <code>git branch -v</code> 命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -v</span></span><br><span class="line">  iss53   93b412c fix javascript issue</span><br><span class="line">* master  7a98805 Merge branch 'iss53'</span><br><span class="line">  testing 782fd34 add scott to the author list in the readmes</span><br></pre></td></tr></table></figure>

<p><strong>查看已经合并到当前分支的分支</strong></p>
<p>如果你要查看哪些分支已经合并到当前分支，可以运行 <code>git branch --merged</code>：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --merged</span></span><br><span class="line">  iss53</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<p>因为之前已经合并了 <code>iss53</code> 分支，所以现在看到它在列表中。 在这个列表中分支名字前没有 <code>*</code> 号的分支通常可以使用 <code>git branch -d</code> 删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。</p>
<p><strong>查看未合并到当前分支的分支</strong></p>
<p>如果你查看所有包含未合并工作的分支，可以运行 <code>git branch --no-merged</code>：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --no-merged</span></span><br><span class="line">  testing</span><br></pre></td></tr></table></figure>

<p>这里显示了其他分支。 因为它包含了还未合并的工作，尝试使用 <code>git branch -d</code> 命令删除它时会失败：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d testing</span></span><br><span class="line">error: The branch 'testing' is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run 'git branch -D testing'.</span><br></pre></td></tr></table></figure>

<p>如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用 <code>-D</code> 选项强制删除它。</p>
<h2 id="4-Git远程分支操作。"><a href="#4-Git远程分支操作。" class="headerlink" title="4. Git远程分支操作。"></a>4. Git远程分支操作。</h2><p>本节将主要介绍本地分支与远程分支之间的交互，而<strong>远程分支是远程引用的一部分，远程引用是对远程仓库的引用，包括分支、标签等</strong>，所以我们先介绍远程仓库的一些概念与操作，再介绍远程分支的操作。</p>
<h3 id="4-1-远程仓库"><a href="#4-1-远程仓库" class="headerlink" title="4.1 远程仓库"></a>4.1 远程仓库</h3><p>远程仓库即在远程服务器上的Git仓库，仓库中可能包含多个分支，我们可以通过添加远程仓库的方式来将一个远程仓库本地化。本节将分别介绍如何添加远程仓库，如何查看远程仓库的信息，如何从远程仓库中抓取(fetch)与拉取(pull)数据，如何从本地推送数据到远程仓库的远程分支上，以及如何重命名和移除远程仓库。<strong>在整个介绍过程中需要注意远程仓库的远程分支与本地分支的关系</strong>。</p>
<p><strong>添加远程仓库</strong></p>
<p>如果你想添加一个远程仓库，运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br><span class="line">origin</span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add pb https://github.com/paulboone/ticgit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line">origin	https://github.com/schacon/ticgit (fetch)</span><br><span class="line">origin	https://github.com/schacon/ticgit (push)</span><br><span class="line">pb	https://github.com/paulboone/ticgit (fetch)</span><br><span class="line">pb	https://github.com/paulboone/ticgit (push)</span><br></pre></td></tr></table></figure>

<p>现在你可以在命令行中使用字符串 <code>pb</code> 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 <code>git fetch pb</code>：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch pb</span></span><br><span class="line">remote: Counting objects: 43, done.</span><br><span class="line">remote: Compressing objects: 100% (36/36), done.</span><br><span class="line">remote: Total 43 (delta 10), reused 31 (delta 5)</span><br><span class="line">Unpacking objects: 100% (43/43), done.</span><br><span class="line">From https://github.com/paulboone/ticgit</span><br><span class="line"> * [new branch]      master     -&gt; pb/master</span><br><span class="line"> * [new branch]      ticgit     -&gt; pb/ticgit</span><br></pre></td></tr></table></figure>

<p>现在 Paul 的 master 分支可以在本地通过 <code>pb/master</code> 访问到。</p>
<p><strong>查看远程仓库</strong></p>
<p>如果想<strong>查看你已经配置的远程仓库服务器</strong>，可以运行 <code>git remote</code> 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin（这是 Git 给你克隆的仓库服务器的默认名字）：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/schacon/ticgit</span></span><br><span class="line">Cloning into 'ticgit'...</span><br><span class="line">remote: Reusing existing pack: 1857, done.</span><br><span class="line">remote: Total 1857 (delta 0), reused 0 (delta 0)</span><br><span class="line">Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (772/772), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ticgit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure>

<p>你也可以指定选项 <code>-v</code>，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line">origin	https://github.com/schacon/ticgit (fetch)</span><br><span class="line">origin	https://github.com/schacon/ticgit (push)</span><br></pre></td></tr></table></figure>

<p>如果你的远程仓库不止一个，该命令会将它们全部列出。</p>
<p>如果想要<strong>查看某一个远程仓库的更多信息</strong>，可以使用 <code>git remote show [remote-name]</code> 命令。 如果想以一个特定的缩写名运行这个命令，例如 <code>origin</code>，会得到像下面类似的信息：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote show origin</span></span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/schacon/ticgit</span><br><span class="line">  Push  URL: https://github.com/schacon/ticgit</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master                               tracked</span><br><span class="line">    dev-branch                           tracked</span><br><span class="line">  Local branch configured for 'git pull':</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured for 'git push':</span><br><span class="line">    master pushes to master (up to date)</span><br></pre></td></tr></table></figure>

<p>它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 master 分支，并且如果运行 git pull，就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。 它也会列出拉取到的所有远程引用。</p>
<p><strong>从远程仓库中抓取与拉取</strong></p>
<p>如果你想<strong>从远程仓库中抓取数据</strong>，可以执行<code>git fetch [remote-name]</code>，这个命令会访问远程仓库，将所有远程仓库中的远程分支更新到本地。 执行完成后，你将会拥有<strong>那个远程仓库中所有分支的引用</strong>，可以随时合并或查看。</p>
<p>如果你使用 <code>clone</code> 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。必须注意 <code>git fetch</code> 命令会<strong>将数据拉取到你的本地仓库，它并不会自动合并或修改你当前的工作，当准备好时你必须手动将其合并入你的工作。</strong></p>
<p>如果当前分支与远程分支存在追踪关系，<code>git pull</code>就可以省略远程分支名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin</span><br></pre></td></tr></table></figure>

<p>上面命令表示，本地的当前分支自动与对应的<code>origin</code>主机”追踪分支”(remote-tracking branch)进行合并。</p>
<p><strong>推送到远程仓库</strong></p>
<p>如果你想<strong>将本地项目推送到远程仓库</strong>，你可以运行命令<code>git push [remote-name] [branch-name]</code>。 例如，当你想要将 master 分支推送到 <code>origin</code> 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到远程仓库：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin master</span></span><br></pre></td></tr></table></figure>

<p>*<em>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 *</em>当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。</p>
<p><strong>远程仓库的重命名与移除</strong></p>
<p>如果想要<strong>重命名引用的名字</strong>可以运行 <code>git remote rename</code> 去修改一个远程仓库的简写名。 例如，想要将 <code>pb</code> 重命名为 <code>paul</code>，可以用 <code>git remote rename</code> 这样做：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote rename pb paul</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure>

<p>值得注意的是这同样也会修改你的远程分支名字。 那些过去引用 <code>pb/master</code> 的现在会引用 <code>paul/master</code>。</p>
<p>如果因为一些原因想要<strong>移除一个远程仓库</strong> ，你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了 - 可以使用 <code>git remote rm</code> ：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote rm paul</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure>

<h3 id="4-2-远程分支"><a href="#4-2-远程分支" class="headerlink" title="4.2 远程分支"></a>4.2 远程分支</h3><p>远程分支指在远程仓库中的分支，而我们在将远程仓库中的远程分支通过抓取数据命令本地化后，Git都会为远程分支创建<strong>远程追踪分支</strong>。远程追踪分支是不能移动的本地引用，以 <code>(remote)/(branch)</code> 形式命名，当我们做任何网络通信操作时，它们会自动移动。本节将介绍如何添加远程分支，如何追踪远程分支，如何查看追踪分支信息，如何把本地分支推送到远程分支，以及如何删除远程分支。</p>
<p><strong>添加远程分支</strong></p>
<p>如果我们要从远程仓库的远程分支上抓取数据一般会通过两种方式：<code>git fetch</code>和<code>git pull</code>。</p>
<p>如果我们要从远程仓库抓取某个分支的数据，可以运行<code>git fetch [remote-name] [branch-name]</code>命令。 例如，运行<code>git fetch origin master</code>命令，你可以将远程仓库<code>origin</code>上的<code>master</code>分支抓取下来，Git会在本地新建一个<code>origin/master</code>远程追踪分支，但不会自动与本地分支合并。</p>
<p>如果我们想在<code>origin/master</code>基础上进行工作，就需要一个本地分支来追踪<code>origin/master</code>分支。如何追踪？下文将介绍。</p>
<p>有时，先利用<code>git fetch</code>命令再利用本地分支进行追踪会嫌麻烦，我们可以利用<code>git pull</code>命令进行简化。例如，运行<code>git pull origin master</code>命令，Git会在本地新建一个<code>origin/master</code>远程追踪分支，并且会自动创建本地分支<code>master</code>来追踪<code>origin/master</code>分支。</p>
<p><em>git fetch和git pull的区别</em></p>
<p><em>git fetch</em>：相当于是从远程获取最新版本到本地，不会自动合并。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin master</span><br><span class="line">$ git log -p master..origin/master</span><br><span class="line">$ git merge origin/master</span><br></pre></td></tr></table></figure>

<p>以上命令的含义：</p>
<ul>
<li>首先从远程的<code>origin</code>的<code>master</code>主分支下载最新的版本到<code>origin/master</code>分支上</li>
<li>然后比较本地的<code>master</code>分支和<code>origin/master</code>分支的差别</li>
<li>最后进行合并</li>
</ul>
<p>上述过程其实可以用以下更清晰的方式来进行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin master:tmp</span><br><span class="line">$ git diff tmp </span><br><span class="line">$ git merge tmp</span><br></pre></td></tr></table></figure>

<p> <em>git pull</em>：相当于是从远程获取最新版本并<code>merge</code>到本地 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin master</span><br></pre></td></tr></table></figure>

<p>上述命令其实相当于<code>git fetch</code> 和 <code>git merge</code>两个命令。</p>
<p>在实际使用中，<code>git fetch</code>更安全一些，因为在<code>merge</code>前，我们可以查看更新情况，然后再决定是否合并。</p>
<p><strong>追踪分支</strong></p>
<p>我们可以自己创建一个本地分支，然后将本地分支与远程追踪分支进行合共来追踪远程分支。我们可以运行 <code>git checkout -b [branch] [remotename]/[branch]</code>来完成以上操作， 这是一个十分常用的操作，所以 Git 提供了 <code>--track</code> 快捷方式：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout --track origin/serverfix</span></span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch 'serverfix'</span><br></pre></td></tr></table></figure>

<p>如果想要将本地分支与远程分支设置为不同名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b sf origin/serverfix</span></span><br><span class="line">Branch sf set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch 'sf'</span><br></pre></td></tr></table></figure>

<p>现在，本地分支 <code>sf</code> 会自动从 <code>origin/serverfix</code> 拉取。</p>
<p><strong>查看追踪分支信息</strong></p>
<p>如果想要<strong>查看设置的所有跟踪分支</strong>，可以使用 <code>git branch</code> 的 <code>-vv</code> 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -vv</span></span><br><span class="line">  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets</span><br><span class="line">  master    1ae2a45 [origin/master] deploying index fix</span><br><span class="line">* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it</span><br><span class="line">  testing   5ea463a trying something new</span><br></pre></td></tr></table></figure>

<p>这里可以看到 <code>iss53</code> 分支正在跟踪 <code>origin/iss53</code> 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 <code>master</code> 分支正在跟踪 <code>origin/master</code> 分支并且是最新的。 接下来可以看到 <code>serverfix</code> 分支正在跟踪 <code>teamone</code> 服务器上的 <code>server-fix-good</code> 分支并且领先 3 落后 1，意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 <code>testing</code> 分支并没有跟踪任何远程分支。</p>
<p><strong>推送本地分支到远程分支</strong></p>
<p>如果当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步 ，你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。</p>
<p>例如，如果你希望和别人一起在名为 <code>serverfix</code> 的分支上工作，可以推送<strong>第一个</strong>分支，运行 <code>git push [remot-name] [branch-name]</code>:</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin serverfix</span></span><br><span class="line">Counting objects: 24, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (15/15), done.</span><br><span class="line">Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.</span><br><span class="line">Total 24 (delta 2), reused 0 (delta 0)</span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line"> * [new branch]      serverfix -&gt; serverfix</span><br></pre></td></tr></table></figure>

<p>这里有些工作被简化了。 Git 自动将 <code>serverfix</code> 分支名字展开为 <code>refs/heads/serverfix:refs/heads/serverfix</code>，那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。” 如果并不想让远程仓库上的分支叫做 <code>serverfix</code>，可以运行 <code>git push origin serverfix:awesomebranch</code> 来将本地的 <code>serverfix</code> 分支推送到远程仓库上的 <code>awesomebranch</code> 分支。</p>
<p>当然，如果远程仓库中已存在<code>severfix</code>分支，则推送就会出现冲突，需要先将<code>severfix</code>抓取下来，与本地分支合并之后，再进行推送。</p>
<p><strong>删除远程分支</strong></p>
<p>如果你已经通过远程分支做完所有的工作了 ，例如，你和你的协作者已经完成了一个特性并且将其合并到了远程仓库的 <code>master</code> 分支。可以运行带有 <code>--delete</code> 选项的 <code>git push</code> 命令来删除一个远程分支。 例如，想要从服务器上删除 <code>serverfix</code> 分支，运行下面的命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete serverfix</span></span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line"> - [deleted]         serverfix</span><br></pre></td></tr></table></figure>

<p>基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要是摘抄及整理了两个教程的文字，通过三个层次（单分支、多分支及远程分支）来介绍Git的概念及使用。首先，在不讨论分支概念的情况下，介绍单分支场景下的文件操作；然后，在本地环境下，介绍多分支的分支操作；最后，加入远程仓库，介绍远程分支与本地分支的交互。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">git官方教程</a></p>
<p><a href="https://www.yiibai.com/git/" target="_blank" rel="noopener">git易百教程</a></p>
</center>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/15/Git入门笔记/" data-id="ck0kz0noi0004kst0xiafy70u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构与算法（剑指offer）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/15/数据结构与算法（剑指offer）/" class="article-date">
  <time datetime="2019-09-15T12:43:26.867Z" itemprop="datePublished">2019-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/15/数据结构与算法（剑指offer）/">数据结构与算法（剑指offer）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="数据结构与算法（剑指offer）"><a href="#数据结构与算法（剑指offer）" class="headerlink" title="数据结构与算法（剑指offer）"></a>数据结构与算法（剑指offer）</h1><h2 id="进制表示、位运算-4’"><a href="#进制表示、位运算-4’" class="headerlink" title="进制表示、位运算 4’"></a>进制表示、位运算 4’</h2><h3 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h3><p><strong>题目描述</strong></p>
<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<h3 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h3><p><strong>题目描述</strong></p>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<h3 id="求1-2-3-···-n"><a href="#求1-2-3-···-n" class="headerlink" title="求1+2+3+···+n"></a>求1+2+3+···+n</h3><p><strong>题目描述</strong></p>
<p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<h3 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h3><p><strong>题目描述</strong></p>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<h2 id="字符串-8’"><a href="#字符串-8’" class="headerlink" title="字符串 8’"></a>字符串 8’</h2><h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><p><strong>题目描述</strong></p>
<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<h3 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h3><p><strong>题目描述</strong></p>
<p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）。</p>
<h3 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h3><p><strong>题目描述</strong></p>
<p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<h3 id="旋转单词顺序列"><a href="#旋转单词顺序列" class="headerlink" title="旋转单词顺序列"></a>旋转单词顺序列</h3><p><strong>题目描述</strong></p>
<p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<h3 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h3><p><strong>题目描述</strong></p>
<p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p>
<p><strong>输入描述</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个字符串,包括数字字母符号,可以为空</span><br></pre></td></tr></table></figure>

<p><strong>输出描述</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果是合法的数值表达则返回该数字，否则返回0</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">+2147483647</span><br><span class="line">    1a33</span><br><span class="line">输出：</span><br><span class="line">2147483647</span><br><span class="line">    0</span><br></pre></td></tr></table></figure>

<h3 id="正则表达是匹配"><a href="#正则表达是匹配" class="headerlink" title="正则表达是匹配"></a>正则表达是匹配</h3><p><strong>题目描述</strong></p>
<p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配。</p>
<h3 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h3><p><strong>题目描述</strong></p>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<h3 id="字符流中第一个不重复的字符"><a href="#字符流中第一个不重复的字符" class="headerlink" title="字符流中第一个不重复的字符"></a>字符流中第一个不重复的字符</h3><p><strong>题目描述</strong></p>
<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p>
<p><strong>输出描述</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果当前字符流没有存在出现一次的字符，返回#字符。</span><br></pre></td></tr></table></figure>

<h2 id="数组-6’"><a href="#数组-6’" class="headerlink" title="数组 6’"></a>数组 6’</h2><h3 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h3><p><strong>题目描述</strong></p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<h3 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h3><p><strong>题目描述</strong></p>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10。</p>
<h3 id="数组中出现次数超过一半的数组"><a href="#数组中出现次数超过一半的数组" class="headerlink" title="数组中出现次数超过一半的数组"></a>数组中出现次数超过一半的数组</h3><p><strong>题目描述</strong></p>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<h3 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h3><p><strong>题目描述</strong></p>
<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<h3 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h3><p><strong>题目描述</strong></p>
<p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]*A[i+1]</em>…*A[n-1]。不能使用除法。</p>
<h3 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h3><p><strong>题目描述</strong></p>
<p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<h2 id="链表-8’"><a href="#链表-8’" class="headerlink" title="链表 8’"></a>链表 8’</h2><h3 id="从头到尾打印链表"><a href="#从头到尾打印链表" class="headerlink" title="从头到尾打印链表"></a>从头到尾打印链表</h3><p><strong>题目描述</strong></p>
<p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>
<h3 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h3><p><strong>题目描述</strong></p>
<p>输入一个链表，输出该链表中倒数第k个结点。</p>
<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p><strong>题目描述</strong></p>
<p>输入一个链表，反转链表后，输出新链表的表头。</p>
<h3 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h3><p><strong>题目描述</strong></p>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<h3 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h3><p><strong>题目描述</strong></p>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）。</p>
<h3 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h3><p><strong>题目描述</strong></p>
<p>输入两个链表，找出它们的第一个公共结点。</p>
<h3 id="链表中环的入口节点"><a href="#链表中环的入口节点" class="headerlink" title="链表中环的入口节点"></a>链表中环的入口节点</h3><p><strong>题目描述</strong></p>
<p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<h3 id="删除链表中重复的结点"><a href="#删除链表中重复的结点" class="headerlink" title="删除链表中重复的结点"></a>删除链表中重复的结点</h3><p><strong>题目描述</strong></p>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5。</p>
<h2 id="栈、队列-3’"><a href="#栈、队列-3’" class="headerlink" title="栈、队列 3’"></a>栈、队列 3’</h2><h3 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h3><p><strong>题目描述</strong></p>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h3 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h3><p><strong>题目描述</strong></p>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O(1)）。</p>
<h3 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h3><p><strong>题目描述</strong></p>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）。</p>
<h2 id="树-15’"><a href="#树-15’" class="headerlink" title="树 15’"></a>树 15’</h2><h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3><p><strong>题目描述</strong></p>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<h3 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h3><p><strong>题目描述</strong></p>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<h3 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h3><p><strong>题目描述</strong></p>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<p><strong>输入描述</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树 </span><br><span class="line">    	    8</span><br><span class="line">    	   /  \</span><br><span class="line">    	  6   10</span><br><span class="line">    	 / \  / \</span><br><span class="line">    	5  7 9 11</span><br><span class="line">    	镜像二叉树</span><br><span class="line">    	    8</span><br><span class="line">    	   /  \</span><br><span class="line">    	  10   6</span><br><span class="line">    	 / \  / \</span><br><span class="line">    	11 9 7  5</span><br></pre></td></tr></table></figure>

<h3 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h3><p><strong>题目描述</strong></p>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<h3 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h3><p><strong>题目描述</strong></p>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<h3 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h3><p><strong>题目描述</strong></p>
<p>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p>
<h3 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h3><p><strong>题目描述</strong></p>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><p><strong>题目描述</strong></p>
<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p><strong>题目描述</strong></p>
<p>输入一个二叉树，判断二叉树是否是平衡树。</p>
<h3 id="二叉树的下一个节点"><a href="#二叉树的下一个节点" class="headerlink" title="二叉树的下一个节点"></a>二叉树的下一个节点</h3><p><strong>题目描述</strong></p>
<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<h3 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h3><p><strong>题目描述</strong></p>
<p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<h3 id="按之字形顺序打印二叉树"><a href="#按之字形顺序打印二叉树" class="headerlink" title="按之字形顺序打印二叉树"></a>按之字形顺序打印二叉树</h3><p><strong>题目描述</strong></p>
<p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<h3 id="把二叉树打印成多行"><a href="#把二叉树打印成多行" class="headerlink" title="把二叉树打印成多行"></a>把二叉树打印成多行</h3><p><strong>题目描述</strong></p>
<p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<h3 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h3><p><strong>题目描述</strong></p>
<p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<h3 id="二叉搜索树的第k个节点"><a href="#二叉搜索树的第k个节点" class="headerlink" title="二叉搜索树的第k个节点"></a>二叉搜索树的第k个节点</h3><p><strong>题目描述</strong></p>
<p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p>
<h2 id="查找-3’"><a href="#查找-3’" class="headerlink" title="查找 3’"></a>查找 3’</h2><h3 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h3><p><strong>题目描述</strong></p>
<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h3 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h3><p><strong>题目描述</strong></p>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<h3 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h3><p><strong>题目描述</strong></p>
<p>统计一个数字在排序数组中出现的次数。</p>
<h2 id="排序-4’"><a href="#排序-4’" class="headerlink" title="排序 4’"></a>排序 4’</h2><h3 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a>最小的K个数</h3><p><strong>题目描述</strong></p>
<p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p>
<h3 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h3><p><strong>题目描述</strong></p>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<h3 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h3><p><strong>题目描述</strong></p>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。</p>
<p><strong>输入描述</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">	1,2,3,4,5,6,7,0</span><br><span class="line">输出：</span><br><span class="line">	7</span><br></pre></td></tr></table></figure>

<h3 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h3><p><strong>题目描述</strong></p>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<h2 id="递归、动态规划-8’"><a href="#递归、动态规划-8’" class="headerlink" title="递归、动态规划 8’"></a>递归、动态规划 8’</h2><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p><strong>题目描述</strong></p>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，n&lt;=39）。</p>
<h3 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h3><p><strong>题目描述</strong></p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<h3 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h3><p><strong>题目描述</strong></p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<h3 id="矩阵覆盖"><a href="#矩阵覆盖" class="headerlink" title="矩阵覆盖"></a>矩阵覆盖</h3><p><strong>题目描述</strong></p>
<p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<h3 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h3><p><strong>题目描述</strong></p>
<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<h3 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h3><p><strong>题目描述</strong></p>
<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<p><strong>输入描述</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</span><br></pre></td></tr></table></figure>

<h3 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h3><p><strong>题目描述</strong></p>
<p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p>
<h2 id="回溯法-2’"><a href="#回溯法-2’" class="headerlink" title="回溯法 2’"></a>回溯法 2’</h2><h3 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h3><p><strong>题目描述</strong></p>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<h3 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h3><p><strong>题目描述</strong></p>
<p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<h2 id="数学问题-6’"><a href="#数学问题-6’" class="headerlink" title="数学问题 6’"></a>数学问题 6’</h2><h3 id="整数中1出现的次数"><a href="#整数中1出现的次数" class="headerlink" title="整数中1出现的次数"></a>整数中1出现的次数</h3><p><strong>题目描述</strong></p>
<p>求出1<del>13的整数中1出现的次数,并算出100</del>1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p>
<h3 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h3><p><strong>题目描述</strong></p>
<p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<h3 id="和为S的连续正数序列"><a href="#和为S的连续正数序列" class="headerlink" title="和为S的连续正数序列"></a>和为S的连续正数序列</h3><p><strong>题目描述</strong></p>
<p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p>
<p><strong>输出描述</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</span><br></pre></td></tr></table></figure>

<h3 id="和为S的两个数字"><a href="#和为S的两个数字" class="headerlink" title="和为S的两个数字"></a>和为S的两个数字</h3><p><strong>题目描述</strong></p>
<p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<p><strong>输出描述</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对应每个测试案例，输出两个数，小的先输出。</span><br></pre></td></tr></table></figure>

<h3 id="扑克牌顺子"><a href="#扑克牌顺子" class="headerlink" title="扑克牌顺子"></a>扑克牌顺子</h3><p><strong>题目描述</strong></p>
<p>从扑克牌中随机抽取5张牌，判断是不是一个数字，即这5张牌是不是连续的。2-10为数字本身，A为1，J为11，Q为12，K为13，大小王可以看成任意数字。</p>
<h3 id="圆圈中最后剩下的数字（约瑟夫环问题）"><a href="#圆圈中最后剩下的数字（约瑟夫环问题）" class="headerlink" title="圆圈中最后剩下的数字（约瑟夫环问题）"></a>圆圈中最后剩下的数字（约瑟夫环问题）</h3><p><strong>题目描述</strong></p>
<p>0，1，…，n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈中里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/15/数据结构与算法（剑指offer）/" data-id="ck0kz0no50002kst0j6saiqz5" class="article-share-link">Share</a>
=======
      <a data-url="http://yoursite.com/2018/05/30/The-understanding-and-realization-of-DNC/" data-id="cjhsu697z00005h8qdl6qv2mf" class="article-share-link">Share</a>
>>>>>>> origin/master
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
<<<<<<< HEAD
    <a href="/2019/09/15/hello-world/" class="article-date">
  <time datetime="2019-09-15T09:11:54.027Z" itemprop="datePublished">2019-09-15</time>
=======
    <a href="/2018/05/30/hello-world/" class="article-date">
  <time datetime="2018-05-30T07:25:34.678Z" itemprop="datePublished">2018-05-30</time>
>>>>>>> origin/master
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
<<<<<<< HEAD
      <a class="article-title" href="/2019/09/15/hello-world/">Hello World</a>
=======
      <a class="article-title" href="/2018/05/30/hello-world/">Hello World</a>
>>>>>>> origin/master
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<<<<<<< HEAD

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

=======
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
>>>>>>> origin/master
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
<<<<<<< HEAD
      <a data-url="http://yoursite.com/2019/09/15/hello-world/" data-id="ck0kz0nnm0000kst0u36tul79" class="article-share-link">Share</a>
=======
      <a data-url="http://yoursite.com/2018/05/30/hello-world/" data-id="cjhsu698600015h8qil4hk6vy" class="article-share-link">Share</a>
>>>>>>> origin/master
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
<<<<<<< HEAD
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
=======
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li></ul>
>>>>>>> origin/master
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
<<<<<<< HEAD
            <a href="/2019/09/15/SSH基本原理/">SSH 基本原理</a>
          </li>
        
          <li>
            <a href="/2019/09/15/JVM笔记（理论篇）/">JVM 笔记（理论篇）</a>
          </li>
        
          <li>
            <a href="/2019/09/15/Git入门笔记/">Git 入门笔记</a>
          </li>
        
          <li>
            <a href="/2019/09/15/数据结构与算法（剑指offer）/">数据结构与算法（剑指offer）</a>
          </li>
        
          <li>
            <a href="/2019/09/15/hello-world/">Hello World</a>
=======
            <a href="/2018/05/30/The-understanding-and-realization-of-DNC/">The understanding and realization of DNC</a>
          </li>
        
          <li>
            <a href="/2018/05/30/hello-world/">Hello World</a>
>>>>>>> origin/master
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
<<<<<<< HEAD
      &copy; 2019 Zhou Jianbo<br>
=======
      &copy; 2018 John Doe<br>
>>>>>>> origin/master
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>